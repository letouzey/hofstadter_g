diff --git a/FunG.v b/FunG.v
index 0f8c479..e9fa029 100644
--- a/FunG.v
+++ b/FunG.v
@@ -1565,6 +1565,94 @@ Qed.
     The current proof is rather convoluted.
 *)
 
+Require Import Bool.
+
+Fixpoint mem a l :=
+ match l with
+ | [] => false
+ | x::l => (a=?x) || mem a l
+ end.
+
+Fixpoint delta_n_fib l a :=
+ if negb (mem a l) then Eq
+ else
+   match a with
+   | 0 => Eq
+   | 1 | 2 => Lt
+   | 3 => Gt
+   | S (S a') => delta_n_fib l a'
+   end.
+
+Compute fib(2)+fib(4).
+Compute fib(3).
+Compute fib(5).
+
+(*
+
+> g_add_1 :  1=fib 2
+>  g(1+n)=0+g(n)=g(n)+g(1)-1 ssi Two 2 n
+>  g(1+n)=1+g(n)=g(n)+g(1)+0 ssi ~Two 2 n
+>
+> g_add_2 : 2=fib 3
+>  g(2+n)=1+g(n)=g(n)+g(2)+0 ssi ~Three 2 n
+>  g(2+n)=2+g(n)=g(n)+g(2)+1 ssi Three 2 n
+>
+> g_add_fib : fib(a) avec a>3
+>  soit fib(a) dans la décomp de n
+>   et alors fib(a-1) n'y est pas et HR(fib(a-2)) (même parité que fib(a))
+>   g(n+fib(a))=g(n'+fib(a-2))   avec n' = n+fib(a-1)
+>              =g(n)+fib(a-2) + fib(a-3) + delta(n',fib(a-2))
+>              =g(n)+fib(a-1)            + delta(n',fib(a-2))
+>  soit fib(a-1) pas dans la décomp de n
+>   g(n+fib(a))=g(n)+fib(a-1)  exact
+>
+> Donc delta(n,fib(2)) = if Two(n) then -1 else 0
+>     delta(n,fib(3)) = if Three(n) then 1 else 0
+>
+>     delta(n,fib(a)) =
+>       if In a (decomp n) then delta(n+fib(a-1),fib(a-2))
+>       else 0
+>
+> n+fib(a-1) est lax donc attention à la renorm,
+> or on est dans le cas In a (decomp(n)) donc
+>    renorm(n+fib(a-1)) = renorm(n-fib(a)+fib(a+1))
+>     en tout cas ne change pas le bas (Two et Three)
+>
+> delta(n,fib(a)) =
+>  0 s'il existe b dans [2..a] et de même parité que a et pas dans decomp(n)
+>  1 si n = ... a (a-2) (a-4) ... 3   (en particulier a impair)
+>   -1 si n = .... a (a-2) (a-4) ... 2 (en particulier a pair)
+
+--------
+
+plus généralement
+ delta(n,0) = Eq
+
+ delta(n,fib(a)+fib(b)+p')
+  si a+2 < b
+   si ~In b (decomp n) then delta(n+fib(b),fib(a)+p')
+   si In b (decomp n) then delta(n+fib(b-1),fib(a)+fib(b-2)+p')
+  si a+2 = b
+   si ~In a (decomp n) then delta(n+fib(a),fib(b)+p')
+   si In a (decomp n)
+    si 3<a then delta(n+fib(a-1),fib(a-2)+fib(b)+p')
+    si a=3 then opp_compare (delta (n+1,fib(2)+fib(b)+p')
+    si a=2 then opp_compare (delta (n+2,fib(3)+p')
+
+
+methode plus directe (?):
+- basculer dans n tous les fib de p pas dans n (/!\ dans le cas du plus petit, ça peut changer rank(p)
+- pour chaque écart >=3 entre les fib de p (ou si 3<indicebas)
+   b=a+3 --> a,a+1 = a+2
+   b=a+4 --> a,a+2 ras
+- reste ensuite :
+  n = ... a (a-2) (a-4) ... 3
+  ou
+  n = ... a (a-2) (a-4) ... 2
+
+
+*)
+
 Lemma g_add_approx n p :
   g n + g p - 1 + (rank p) mod 2 <= g (n+p) <= g n + g p + (rank p) mod 2.
 Proof.
