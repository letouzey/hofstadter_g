From Coq Require Import Permutation.
Require Import MoreList DeltaList FunG GenFib GenG.
Import ListNotations.

(** * Morphic words

    Some theory of infinite words generated by substitutions.
    Hofstadter functions [f k] can be described by such infinite
    words, or more precisely their derivative
    (fun n => f k (S n) - f k n)
*)

(** letters : here some natural numbers *)

Definition letter := nat.

(** Finite word : list of letters *)

Definition word := list letter.

(** Some predicates on words : Prefix, Suffix, Sub *)

Definition Prefix (u v:word) := exists w, u++w = v.
Definition Suffix (u v:word) := exists w, w++u = v.
Definition Sub (u v:word) := exists w w', w++u++w' = v.

Lemma Prefix_id w : Prefix w w.
Proof.
 exists []. apply app_nil_r.
Qed.

Lemma Prefix_trans u v w : Prefix u v -> Prefix v w -> Prefix u w.
Proof.
 intros (u',<-) (v',<-). exists (u'++v'). apply app_assoc.
Qed.

Lemma Prefix_len u v : Prefix u v -> length u <= length v.
Proof.
 intros (w,<-). rewrite app_length. lia.
Qed.

Lemma Prefix_antisym u v : Prefix u v -> Prefix v u -> u = v.
Proof.
 intros (u',<-) P. apply Prefix_len in P. rewrite app_length in P.
 assert (length u' = 0) by lia.
 destruct u'. now rewrite app_nil_r. easy.
Qed.

Lemma Prefix_nil u : Prefix u [] -> u = [].
Proof.
 intros Pr. apply Prefix_len in Pr. simpl in Pr. now destruct u.
Qed.

Lemma Prefix_cons a u v : Prefix u v -> Prefix (a::u) (a::v).
Proof.
 intros (w,<-). now exists w.
Qed.

Lemma Prefix_nth u v :
  Prefix u v <-> forall n a, n < length u -> nth n u a = nth n v a.
Proof.
 split.
 - intros (w & <-). intros n a LT. rewrite app_nth1; auto.
 - revert v. induction u; intros v H.
   + now exists v.
   + destruct v.
     * specialize (H 0 (S a)). simpl in H. lia.
     * assert (P : Prefix u v).
       { apply IHu. intros n b H'. apply (H (S n) b); simpl; auto with arith. }
       destruct P as (w & P).
       exists w. simpl. f_equal; auto.
       apply (H 0 0). simpl. lia.
Qed.

Lemma Prefix_cons_inv a u v :
  Prefix u (a::v) -> u = [] \/ exists u', u = a::u' /\ Prefix u' v.
Proof.
 intros (w,E).
 destruct u as [|a' u'].
 - now left.
 - right. exists u'. injection E as -> E'. split; auto. now exists w.
Qed.

Lemma Prefix_Prefix u v w : length u <= length v ->
  Prefix u w -> Prefix v w -> Prefix u v.
Proof.
 intros L. rewrite !Prefix_nth. intros P P' n a Hn.
 now rewrite P, P' by lia.
Qed.

Lemma Prefix_app u v w :
 Prefix u (v++w) -> Prefix u v \/ exists u', u = v++u' /\ Prefix u' w.
Proof.
 revert v w.
 induction u.
 - intros v w _. left. now exists v.
 - intros v w (t,E). simpl in E.
   destruct v.
   + right. exists (a::u). split; auto. now exists t.
   + injection E as <- E.
     destruct (IHu v w) as [IH|(u',IH)]; try now exists t.
     * left. now apply Prefix_cons.
     * right. exists u'. simpl; split. now f_equal. apply IH.
Qed.

Lemma Prefix_seq w a n :
 Prefix w (List.seq a n) -> w = List.seq a (length w).
Proof.
 revert w a.
 induction n as [|n IH]; simpl; intros w a P.
 - apply Prefix_nil in P. now subst w.
 - apply Prefix_cons_inv in P. destruct P as [->|(w' & -> & P)]; trivial.
   simpl. f_equal; auto.
Qed.

Lemma Prefix_rev_Suffix u v : Prefix (rev u) (rev v) <-> Suffix u v.
Proof.
 split; intros (w,E).
 - exists (rev w).
   rewrite <- (rev_involutive w), <- rev_app_distr in E.
   now apply rev_inj in E.
 - exists (rev w). now rewrite <- rev_app_distr, E.
Qed.

Lemma Suffix_rev_Prefix u v : Suffix (rev u) (rev v) <-> Prefix u v.
Proof.
 now rewrite <- Prefix_rev_Suffix, !rev_involutive.
Qed.

Lemma Suffix_id w : Suffix w w.
Proof.
 now exists [].
Qed.

Lemma Suffix_len u v : Suffix u v -> length u <= length v.
Proof.
 intros (w,<-). rewrite app_length. lia.
Qed.

Lemma Suffix_nil u : Suffix u [] -> u = [].
Proof.
 intros Su. apply Suffix_len in Su. simpl in Su. now destruct u.
Qed.

Lemma Suffix_app_l l u v : Suffix u v -> Suffix u (l++v).
Proof.
 intros (w,<-). exists (l++w). now rewrite app_ass.
Qed.

Lemma Suffix_app_r u v r : Suffix u v -> Suffix (u++r) (v++r).
Proof.
 intros (w,<-). exists w. now rewrite app_ass.
Qed.

Lemma Suffix_cons_inv a u v :
 Suffix u (a::v) -> u = a::v \/ Suffix u v.
Proof.
 intros ([|a' w],E).
 - now left.
 - right. injection E as -> E. now exists w.
Qed.

Lemma Suffix_app_inv u v w :
 Suffix u (v++w) -> Suffix u w \/ exists u', u = u'++w /\ Suffix u' v.
Proof.
 revert u. induction v as [|a v IH]; intros u H.
 - now left.
 - simpl in H. apply Suffix_cons_inv in H. destruct H as [->|H].
   + right. exists (a::v); split; auto. apply Suffix_id.
   + apply IH in H. destruct H as [H|(u' & E & H)].
     * now left.
     * right. exists u'; split; auto. now apply (Suffix_app_l [a]).
Qed.

Lemma Suffix_seq w a n :
 Suffix w (List.seq a n) -> w = List.seq (a+n-length w) (length w).
Proof.
 revert w a.
 induction n as [|n IH]; simpl; intros w a P.
 - apply Suffix_nil in P. now subst w.
 - apply Suffix_cons_inv in P. destruct P as [E|P].
   + replace (length w) with (S n).
     2:{ subst. simpl. now rewrite seq_length. }
     replace (a+_-_) with a by lia. trivial.
   + apply IH in P. rewrite P at 1. f_equal. lia.
Qed.

Lemma Sub_id w : Sub w w.
Proof.
 exists [], []. now rewrite app_nil_r.
Qed.

Lemma Sub_nil_l u : Sub [] u.
Proof.
 now exists [], u.
Qed.

Lemma Prefix_Sub u v : Prefix u v -> Sub u v.
Proof.
 intros (w,<-). now exists [], w.
Qed.

Lemma Suffix_Sub u v : Suffix u v -> Sub u v.
Proof.
 intros (w,<-). exists w, []. now rewrite app_nil_r.
Qed.

Lemma Sub_len u v : Sub u v -> length u <= length v.
Proof.
 intros (w & w' & <-). rewrite !app_length. lia.
Qed.

Lemma Sub_nil_r u : Sub u [] -> u = [].
Proof.
 intros H. apply Sub_len in H. simpl in H. now destruct u.
Qed.

Lemma Sub_app_l l u v : Sub u v -> Sub u (l++v).
Proof.
 intros (w & w' & <-). exists (l++w), w'. now rewrite app_ass.
Qed.

Lemma Sub_app_r u v r : Sub u v -> Sub u (v++r).
Proof.
 intros (w & w' & <-). exists w, (w'++r). now rewrite !app_ass.
Qed.

Lemma Sub_cons_inv a u v :
 Sub u (a::v) -> Sub u v \/ exists u', u = a::u' /\ Prefix u' v.
Proof.
 intros ([|a' w] & w' & E).
 - destruct u as [|a' u'].
   + left. apply Sub_nil_l.
   + injection E as -> E. right. exists u'. split; trivial. now exists w'.
 - injection E as -> E. left. now exists w, w'.
Qed.

Lemma Sub_app_inv u l r :
 Sub u (l++r) ->
  Sub u l \/ Sub u r \/
  exists u1 u2, u = u1++u2 /\ Suffix u1 l /\ Prefix u2 r.
Proof.
 revert u. induction l as [|a l IH]; intros u H.
 - now (right; left).
 - simpl in H. apply Sub_cons_inv in H. destruct H as [H|(u' & E & H)].
   + apply IH in H. clear IH. destruct H as [H|[H|(u1 & u2 & E & Su & Pr)]].
     * left. now apply (Sub_app_l [a]).
     * now (right; left).
     * right; right. exists u1, u2; repeat split; trivial.
       now apply (Suffix_app_l [a]).
   + subst u. apply Prefix_app in H. destruct H as [H|(u2 & E & Pr)].
     * left. destruct H as (w & <-). now exists [], w.
     * right. right. exists (a::l), u2. repeat split; trivial.
       simpl; now f_equal. apply Suffix_id.
Qed.

Lemma Sub_seq w a n :
 Sub w (List.seq a n) ->
 exists b, a <= b <= a+n-length w /\ w = List.seq b (length w).
Proof.
 revert w a.
 induction n as [|n IH]; simpl; intros w a H.
 - apply Sub_nil_r in H. subst w; simpl. exists a. split; trivial; lia.
 - apply Sub_cons_inv in H. destruct H as [H|(u & E & H)].
   + apply IH in H. destruct H as (b & Hb & E). exists b; split; trivial; lia.
   + subst w; simpl. assert (H' := Prefix_len _ _ H).
     rewrite seq_length in H'.
     apply Prefix_seq in H. exists a; split. lia. now f_equal.
Qed.


(** Sequence a.k.a Infinite word : function from nat to letter *)

Definition sequence := nat -> letter.

Definition PrefixSeq (u:word) (f:sequence) := u = take (length u) f.

(** Substitution : function form letter to words *)

Definition subst := letter -> word.

Fixpoint apply (s:subst) w :=
  match w with
  | [] => []
  | a::w => s a ++ apply s w
  end.

Fixpoint napply (s:subst) n w :=
  match n with
  | 0 => w
  | S n => napply s n (apply s w)
  end.

Lemma napply_1 s u : napply s 1 u = apply s u.
Proof.
 reflexivity.
Qed.

Lemma apply_app s u v : apply s (u++v) = apply s u ++ apply s v.
Proof.
 induction u; simpl; auto.
 now rewrite IHu, app_assoc.
Qed.

Lemma apply_alt s w : apply s w = concat (map s w).
Proof.
 induction w; simpl; auto. now f_equal.
Qed.

Lemma napply_nil s n : napply s n [] = [].
Proof.
 induction n; simpl; auto.
Qed.

Lemma napply_app s n u v : napply s n (u++v) = napply s n u ++ napply s n v.
Proof.
 revert u v. induction n; intros; simpl; auto.
 now rewrite apply_app, IHn.
Qed.

Lemma napply_cons s n a u : napply s n (a::u) = napply s n [a] ++ napply s n u.
Proof.
 apply (napply_app s n [a] u).
Qed.

Lemma napply_alt s n u : napply s (S n) u = apply s (napply s n u).
Proof.
 revert u.
 induction n; intros; simpl; auto.
 now rewrite <- IHn.
Qed.

Lemma napply_add s n m u : napply s (n+m) u = napply s n (napply s m u).
Proof.
 induction n.
 - simpl; auto.
 - now rewrite Nat.add_succ_l, !napply_alt, IHn.
Qed.

Lemma napply_concat s n w :
  napply s n w = concat (map (fun a => napply s n [a]) w).
Proof.
 induction w; simpl; auto using napply_nil.
 rewrite napply_cons. now f_equal.
Qed.

Definition NoErase (s:subst) := forall a, s a <> [].

Definition Prolong (s:subst) a := exists u, u<>[] /\ s a = a::u.

Lemma noerase_nonnil_apply s u : NoErase s -> u<>[] -> apply s u <> [].
Proof.
 intros NE. destruct u as [|a u]. easy. intros _. simpl.
 specialize (NE a). destruct (s a) as [|b v]; easy.
Qed.

Lemma noerase_nonnil_napply s u n : NoErase s -> u<>[] -> napply s n u <> [].
Proof.
 intros NE. revert u. induction n; simpl; intros; auto.
 apply IHn. apply noerase_nonnil_apply; auto.
Qed.

Lemma noerase_prolong_napply_len s a :
  NoErase s -> Prolong s a -> forall n, n < length (napply s n [a]).
Proof.
 intros NE (u & Hu & PR).
 induction n. simpl; auto.
 simpl. rewrite app_nil_r, PR, napply_cons, app_length.
 assert (length (napply s n u) <> 0).
 { rewrite length_zero_iff_nil. now apply noerase_nonnil_napply. }
 lia.
Qed.

Lemma napply_prefix_S s a n :
 Prolong s a -> Prefix (napply s n [a]) (napply s (S n) [a]).
Proof.
 intros (u & Hu & PR).
 simpl. rewrite app_nil_r, PR. rewrite (napply_cons _ _ _ u).
 now exists (napply s n u).
Qed.

Lemma napply_prefix_mono s a n m : Prolong s a -> n <= m ->
 Prefix (napply s n [a]) (napply s m [a]).
Proof.
 intros PR.
 induction 1.
 - exists []. apply app_nil_r.
 - destruct IHle as (w & E).
   destruct (napply_prefix_S s a m) as (w' & E'); auto.
   exists (w++w'). now rewrite app_assoc, E, E'.
Qed.

Lemma apply_grow s w : NoErase s -> length w <= length (apply s w).
Proof.
 intros NE.
 induction w; simpl; auto.
 rewrite app_length. specialize (NE a). destruct (s a); simpl; lia || easy.
Qed.

Lemma napply_mono s n m w :
 NoErase s -> n <= m -> length (napply s n w) <= length (napply s m w).
Proof.
 induction 2; auto.
 rewrite IHle. clear IHle H0. rewrite napply_alt. now apply apply_grow.
Qed.

(** Any nonerasing prolongeable substitution leads to a unique infinite
    sequence *)

Definition SubstSeq (s:subst) (f:sequence) a :=
  forall n, PrefixSeq (napply s n [a]) f.

Definition subst2seq s a :=
 fun n => nth n (napply s n [a]) a.

Lemma subst2seq_indep s a b n : NoErase s -> Prolong s a ->
  forall m, n <= m -> subst2seq s a n = nth n (napply s m [a]) b.
Proof.
 intros. rewrite nth_indep with (d':=a).
 2:{ apply Nat.le_lt_trans with m; trivial.
     apply noerase_prolong_napply_len; trivial. }
 apply Prefix_nth. apply napply_prefix_mono; auto.
 apply noerase_prolong_napply_len; auto.
Qed.

Lemma substseq_exists s a :
  NoErase s -> Prolong s a -> SubstSeq s (subst2seq s a) a.
Proof.
 intros NE PR n.
 red. symmetry. apply take_carac; auto.
 intros m b Hm.
 unfold subst2seq.
 rewrite (nth_indep _ b a); auto.
 destruct (Nat.le_gt_cases n m).
 - apply Prefix_nth; auto.
   apply napply_prefix_mono; auto.
 - symmetry.
   apply Prefix_nth; auto.
   apply napply_prefix_mono; auto with arith.
   apply noerase_prolong_napply_len; auto.
Qed.

Lemma substseq_unique s a f f' :
  NoErase s -> Prolong s a -> SubstSeq s f a -> SubstSeq s f' a ->
  (forall n, f n = f' n).
Proof.
 intros NE PR Hf Hf' n.
 specialize (Hf (S n)).
 specialize (Hf' (S n)). unfold PrefixSeq in *.
 set (u := napply s (S n) [a]) in *.
 rewrite <- (take_nth f (length u) n a).
 2:{ transitivity (S n); auto. apply noerase_prolong_napply_len; auto. }
 rewrite <- (take_nth f' (length u) n a); auto.
 2:{ transitivity (S n); auto. apply noerase_prolong_napply_len; auto. }
 now rewrite <- Hf, <- Hf'.
Qed.

(** Specific susbstitution for Hofstadter functions.
    Works on letters 0..k *)

Definition ksubst k n := if n =? k then [k; 0] else [S n].

Definition kword k n := napply (ksubst k) n [k].

Definition kseq k := subst2seq (ksubst k) k.

(* Compute map (kseq 2) (List.seq 0 20). *)
(* [2; 0; 1; 2; 2; 0; 2; 0; 1; 2; 0; 1; 2; 2; 0; 1; 2; 2; 0; 2] *)

Lemma ksubst_noerase k : NoErase (ksubst k).
Proof.
 red. intros c. unfold ksubst. now case Nat.eqb_spec.
Qed.

Lemma ksubst_prolong k : Prolong (ksubst k) k.
Proof.
 red. exists [0]. split. easy.
 unfold ksubst. now rewrite Nat.eqb_refl.
Qed.

Lemma kseq_SubstSeq k : SubstSeq (ksubst k) (kseq k) k.
Proof.
 apply substseq_exists. apply ksubst_noerase. apply ksubst_prolong.
Qed.

Lemma kword_S k n : kword k (S n) = apply (ksubst k) (kword k n).
Proof.
 apply napply_alt.
Qed.

(** kword letters are always in 0..k *)

Lemma ksubst_letters k w :
 Forall (fun a => a <= k) w ->
 Forall (fun a => a <= k) (apply (ksubst k) w).
Proof.
 induction w; simpl; auto.
 intros H; inversion_clear H. apply Forall_app. split; auto.
 unfold ksubst.
 case Nat.eqb_spec; intro; repeat (constructor; try lia).
Qed.

Lemma napply_ksubst_letters k n w :
 Forall (fun a => a <= k) w ->
 Forall (fun a => a <= k) (napply (ksubst k) n w).
Proof.
 induction n.
 - simpl. trivial.
 - rewrite napply_alt. intros. now apply ksubst_letters, IHn.
Qed.

Lemma kword_letters k n : Forall (fun a => a <= k) (kword k n).
Proof.
 apply napply_ksubst_letters. now constructor.
Qed.

Lemma kseq_letters k n : kseq k n <= k.
Proof.
 unfold kseq, subst2seq.
 set (l := napply _ _ _).
 assert (Forall (fun a => a <= k) l).
 { apply napply_ksubst_letters. now constructor. }
 clearbody l. revert n. induction H; simpl; now destruct n.
Qed.

(** Initial values *)

Lemma kword_0 k : kword k 0 = [k].
Proof.
 reflexivity.
Qed.

Lemma kword_1 k : kword k 1 = [k;0].
Proof.
 cbn. unfold ksubst. now rewrite Nat.eqb_refl.
Qed.

Lemma ksubst_low0 k n : n <= k -> napply (ksubst k) n [0] = [n].
Proof.
 induction n. auto.
 intros LE.
 rewrite napply_alt. rewrite IHn; try lia. simpl.
 unfold ksubst. case Nat.eqb_spec. lia. intros _. apply app_nil_r.
Qed.

Lemma kword_low k n : n <= S k -> kword k n = k :: List.seq 0 n.
Proof.
 induction n.
 - now rewrite kword_0.
 - intros LE.
   rewrite seq_S.
   cbn. unfold ksubst at 2. rewrite Nat.eqb_refl. simpl.
   rewrite napply_cons.
   rewrite ksubst_low0; auto; try lia.
   change (kword k n ++ [n] = k  :: List.seq 0 n ++ [n]).
   rewrite IHn; try lia. auto.
Qed.

(** Alt equation : *)

Lemma kword_alt k n : k<=n -> kword k (S n) = kword k n ++ kword k (n-k).
Proof.
 induction n.
 - intros. replace k with 0 by lia. simpl; auto.
 - intros LE. apply Nat.lt_eq_cases in LE. destruct LE as [LT|EQ].
   + replace (S n -k) with (S (n-k)) by lia.
     remember (S n) as m eqn:E.
     cbn.
     rewrite app_nil_r.
     unfold ksubst at 2. rewrite Nat.eqb_refl.
     rewrite napply_cons. f_equal.
     replace m with (m-k+k) by lia.
     rewrite napply_add. rewrite ksubst_low0 by lia. simpl.
     replace (m-k) with (S (n-k)) by lia.
     simpl. now rewrite app_nil_r.
   + rewrite <- EQ. replace (k-k) with 0 by lia.
     rewrite kword_0. cbn.
     unfold ksubst at 2. rewrite Nat.eqb_refl, app_nil_r.
     rewrite napply_cons. f_equal. apply ksubst_low0. lia.
Qed.

Lemma kword_len k n : length (kword k n) = A k n.
Proof.
 induction n as [[|n] IH] using lt_wf_ind.
 - now rewrite kword_0.
 - case (Nat.le_gt_cases k n) as [LE|GT].
   + rewrite kword_alt; auto. rewrite app_length, !IH; try lia.
     simpl; auto.
   + rewrite kword_low by auto. simpl.
     rewrite seq_length. rewrite !A_base; lia.
Qed.

Lemma kseq_alt k n m a : n < A k m -> kseq k n = nth n (kword k m) a.
Proof.
 intros LE.
 rewrite (kseq_SubstSeq k m).
 change (napply _ _ _) with (kword k m).
 rewrite kword_len, take_nth; auto.
Qed.

Lemma kseq_take_A k n : take (A k n) (kseq k) = kword k n.
Proof.
 apply take_carac.
 - apply kword_len.
 - intros. symmetry. now apply kseq_alt.
Qed.

(** Link between [kseq] and Zeckendorf decomposition :
    0 iff rank 0,
    1 iff rank 1,
    ...
    k iff rank >= k (or no rank, ie n=0)

    Hence 0 in [kseq] whenever the [f k] function is flat.
*)

Definition omin (oa:option nat) (b:nat) :=
  match oa with
  | None => b
  | Some a => Nat.min a b
  end.

Definition bounded_rank k n := omin (rank k n) k.

Lemma kseq_bounded_rank k n : kseq k n = bounded_rank k n.
Proof.
 induction n as [n IH] using lt_wf_ind.
 assert (E := decomp_sum k n).
 assert (D := decomp_delta k n).
 set (l := decomp k n) in *.
 destruct (rev l) as [|a rl] eqn:E'; apply rev_switch in E'.
 - rewrite E' in *. simpl in E. rewrite <- E. easy.
 - assert (A k a <= n < A k (S a)).
   { rewrite <- E, E', sumA_rev.
     split.
     + simpl; lia.
     + apply decomp_max. apply Delta_rev. now rewrite <- E'. }
   rewrite (kseq_alt k n (S a) 0) by lia.
   destruct (Nat.lt_ge_cases a k) as [LT|LE].
   + rewrite kword_low by lia.
     destruct n as [|n]; try easy.
     change (nth _ _ _) with (nth n (List.seq 0 (S a)) 0).
     rewrite !A_base in H; try lia.
     replace n with a by lia.
     rewrite seq_nth by lia. simpl.
     unfold bounded_rank, rank. rewrite decomp_low; simpl; lia.
   + rewrite kword_alt by auto.
     rewrite app_nth2; rewrite kword_len; try lia.
     rewrite <- kseq_alt by (simpl in H; lia).
     rewrite IH by (generalize (@A_nz k a); lia).
     unfold bounded_rank, rank. fold l; rewrite E'; simpl rev.
     replace (decomp _ _) with (rev rl).
     2:{ symmetry; apply decomp_carac.
         - rewrite E' in D. simpl in D. now apply Delta_app_iff in D.
         - revert E. rewrite E'. simpl. rewrite sumA_app. simpl. lia. }
     destruct (rev rl); simpl; lia.
Qed.

(** Another possible susbstitution for Hofstadter functions,
    giving [min (rank n) (S k)] instead of [min (rank n) k].
    Hence it works on 0..(S k) instead of 0..k *)

Definition ksubstbis k n := if n <? k then [S n] else [S k; 0].

Definition kwordbis k n := napply (ksubstbis k) n [S k].

Definition kseqbis k := subst2seq (ksubstbis k) (S k).

(* Compute map (kseqbis 2) (List.seq 0 20). *)
(* [3; 0; 1; 2; 3; 0; 3; 0; 1; 3; 0; 1; 2; 3; 0; 1; 2; 3; 0; 3] *)

Lemma ksubstbis_noerase k : NoErase (ksubstbis k).
Proof.
 red. intros c. unfold ksubstbis. now case Nat.ltb_spec.
Qed.

Lemma ksubstbis_prolong k : Prolong (ksubstbis k) (S k).
Proof.
 red. exists [0]. split. easy.
 unfold ksubstbis. case Nat.ltb_spec; auto; lia.
Qed.

Lemma kseqbis_SubstSeq k : SubstSeq (ksubstbis k) (kseqbis k) (S k).
Proof.
 apply substseq_exists. apply ksubstbis_noerase. apply ksubstbis_prolong.
Qed.

(** Initial values *)

Lemma kwordbis_0 k : kwordbis k 0 = [S k].
Proof.
 reflexivity.
Qed.

Lemma kwordbis_1 k : kwordbis k 1 = [S k; 0].
Proof.
 cbn. unfold ksubstbis.
 case Nat.ltb_spec; auto. lia.
Qed.

Lemma ksubstbis_low0 k n : n <= k -> napply (ksubstbis k) n [0] = [n].
Proof.
 induction n. auto.
 intros LE.
 rewrite napply_alt. rewrite IHn; try lia. simpl.
 unfold ksubstbis. case Nat.ltb_spec; auto. lia.
Qed.

Lemma ksubstbis_low0' k : napply (ksubstbis k) (S k) [0] = [S k; 0].
Proof.
 change (S k) with (1+k) at 1. rewrite napply_add.
 rewrite ksubstbis_low0 by lia. simpl.
 unfold ksubstbis. case Nat.ltb_spec; auto. lia.
Qed.

Lemma kwordbis_low k n : n <= S k -> kwordbis k n = S k :: List.seq 0 n.
Proof.
 induction n.
 - now rewrite kwordbis_0.
 - intros LE.
   rewrite seq_S.
   cbn. unfold ksubstbis at 2. case Nat.ltb_spec; try lia. intros _.
   simpl. rewrite napply_cons.
   rewrite ksubstbis_low0; auto; try lia.
   change (kwordbis k n ++ [n] = S k :: List.seq 0 n ++ [n]).
   rewrite IHn; try lia. auto.
Qed.

(** Alt equation : *)

Lemma kwordbis_alt k n :
  k<n -> kwordbis k (S n) = kwordbis k n ++ kwordbis k (n-k).
Proof.
 induction n.
 - inversion 1.
 - rewrite Nat.lt_succ_r, Nat.lt_eq_cases.
   intros [LT| <-].
   + replace (S n -k) with (S (n-k)) by lia.
     remember (S n) as m eqn:E.
     cbn.
     rewrite app_nil_r.
     unfold ksubstbis at 2. case Nat.ltb_spec; try lia. intros _.
     rewrite napply_cons. f_equal.
     replace m with (m-k+k) by lia.
     rewrite napply_add. rewrite ksubstbis_low0 by lia.
     replace (m-k) with (S (n-k)) by lia.
     simpl. f_equal. unfold ksubstbis.
     do 2 (case Nat.ltb_spec; try lia). auto.
   + clear IHn.
     replace (S k-k) with 1 by lia. rewrite kwordbis_1.
     remember (S k) as m eqn:E.
     unfold kwordbis at 1. simpl. unfold ksubstbis at 2.
     case Nat.ltb_spec; try lia. intros _. simpl.
     rewrite napply_cons. f_equal. subst m. apply ksubstbis_low0'.
Qed.

Lemma kwordbis_len k n : length (kwordbis k n) = A k n.
Proof.
 induction n as [[|n] IH] using lt_wf_ind.
 - now rewrite kwordbis_0.
 - case (Nat.lt_ge_cases k n) as [LT|GE].
   + rewrite kwordbis_alt; auto. rewrite app_length, !IH; try lia.
     simpl; auto.
   + rewrite kwordbis_low by lia. simpl.
     rewrite seq_length. rewrite !A_base; lia.
Qed.

Lemma kseqbis_alt k n m a : n < A k m -> kseqbis k n = nth n (kwordbis k m) a.
Proof.
 intros LE.
 rewrite (kseqbis_SubstSeq k m).
 change (napply _ _ _) with (kwordbis k m).
 rewrite kwordbis_len, take_nth; auto.
Qed.

(** Link between [kseqbis] and Zeckendorf decomposition :
    0 iff rank 0,
    1 iff rank 1,
    ...
    (S k) iff rank > k (or no rank, ie n=0)

    Hence 0 in [kseqbis] whenever the [f k] function is flat.
*)

Definition bounded_rankbis k n := omin (rank k n) (S k).

Lemma kseqbis_bounded_rank k n : kseqbis k n = bounded_rankbis k n.
Proof.
 induction n as [n IH] using lt_wf_ind.
 assert (E := decomp_sum k n).
 assert (D := decomp_delta k n).
 set (l := decomp k n) in *.
 destruct (rev l) as [|a rl] eqn:E'; apply rev_switch in E'.
 - rewrite E' in *. simpl in E. rewrite <- E. easy.
 - assert (A k a <= n < A k (S a)).
   { rewrite <- E, E', sumA_rev.
     split.
     + simpl; lia.
     + apply decomp_max. apply Delta_rev. now rewrite <- E'. }
   rewrite (kseqbis_alt k n (S a) 0) by lia.
   destruct (Nat.le_gt_cases a k) as [LE|LT].
   + rewrite kwordbis_low by lia.
     destruct n as [|n]; try easy.
     change (nth _ _ _) with (nth n (List.seq 0 (S a)) 0).
     rewrite !A_base in H; try lia.
     replace n with a by lia.
     rewrite seq_nth by lia. simpl.
     unfold bounded_rankbis, rank. rewrite decomp_low; simpl; lia.
   + rewrite kwordbis_alt by auto.
     rewrite app_nth2; rewrite kwordbis_len; try lia.
     rewrite <- kseqbis_alt by (simpl in H; lia).
     rewrite IH by (generalize (@A_nz k a); lia).
     unfold bounded_rankbis, rank. fold l; rewrite E'; simpl rev.
     replace (decomp _ _) with (rev rl).
     2:{ symmetry; apply decomp_carac.
         - rewrite E' in D. simpl in D. now apply Delta_app_iff in D.
         - revert E. rewrite E'. simpl. rewrite sumA_app. simpl. lia. }
     destruct (rev rl); simpl; lia.
Qed.

Lemma kseqbis_kseq k n : kseq k n = Nat.min k (kseqbis k n).
Proof.
 rewrite kseq_bounded_rank, kseqbis_bounded_rank.
 unfold bounded_rank, bounded_rankbis.
 destruct rank; simpl; lia.
Qed.

(** The substitution [(ksubst k)^k] is also quite interesting :
    its infinite word is also [kseq k], but it produces it by
    blocks starting by all the [k] letters. *)

Definition ksubstk k n := napply (ksubst k) k [n].

(** Fun fact: for n <= k, ksubst^k(n) = ksubst^n(k) *)

Lemma ksubst_pearl k n :
  n <= k -> napply (ksubst k) k [n] = napply (ksubst k) n [k].
Proof.
 intros LE.
 rewrite <- (ksubst_low0 k n LE).
 rewrite <- (ksubst_low0 k k (Nat.le_refl _)).
 rewrite <- !napply_add. f_equal. lia.
Qed.

Lemma ksubstk_kword k n : n <= k ->
  ksubstk k n = kword k n.
Proof.
 intros. now apply ksubst_pearl.
Qed.

Lemma ksubstk_alt k n : n <= k ->
  ksubstk k n = k :: seq 0 n.
Proof.
 intros. rewrite <- kword_low by lia. now apply ksubstk_kword.
Qed.

Lemma ksubstk_noerase k : NoErase (ksubstk k).
Proof.
 intro a. apply noerase_nonnil_napply; try easy. apply ksubst_noerase.
Qed.

Lemma ksubstk_prolong k : k<>0 -> Prolong (ksubstk k) k.
Proof.
 exists (seq 0 k); split.
 - contradict H. now rewrite <- (seq_length k 0), H.
 - now rewrite ksubstk_alt by lia.
Qed.

Lemma apply_napply s n l :
  apply (fun x => napply s n [x]) l = napply s n l.
Proof.
 induction l; simpl.
 - symmetry. apply napply_nil.
 - rewrite IHl. symmetry. apply napply_cons.
Qed.

Lemma napply_ksubstk k n l :
 napply (ksubstk k) n l = napply (ksubst k) (n*k) l.
Proof.
 induction n; trivial.
 rewrite napply_alt, IHn.
 simpl. rewrite napply_add. apply apply_napply.
Qed.

Definition kseqk k := subst2seq (ksubstk k) k.

Lemma kseqk_kseq k : forall n, kseqk k n = kseq k n.
Proof.
 destruct (Nat.eq_dec k 0) as [->|N].
 - (* We don't really care about k=0, but for the fun... *)
   intros n. unfold kseqk, subst2seq.
   assert (E : napply (ksubstk 0) n [0] = [0]) by now induction n.
   unfold letter in *. rewrite E.
   replace (nth n [0] 0) with 0.
   2:{ now destruct n as [|[|n]]. }
   generalize (kseq_letters 0 n). lia.
 - intros n.
   unfold kseqk.
   rewrite subst2seq_indep with (m:=n) (b:=k);
    auto using ksubstk_noerase, ksubstk_prolong.
   unfold kseq.
   rewrite subst2seq_indep with (m:=n*k) (b:=k);
    auto using ksubst_noerase, ksubst_prolong.
   2:{ destruct k; simpl; lia. }
   f_equal. apply napply_ksubstk.
Qed.


(** Counting letter a in word w *)

Fixpoint nbocc a w :=
 match w with
 | [] => 0
 | b::w' => nbocc a w' + if b =? a then 1 else 0
 end.

(** [nbocc] is similar to [count_occ Nat.eq_dec], but more convenient
    (order of arguments, Nat.eqb instead of Nat.eq_dec) *)

Lemma nbocc_alt a w : nbocc a w = count_occ Nat.eq_dec w a.
Proof.
 induction w; simpl; auto. rewrite IHw.
 case Nat.eq_dec; case Nat.eqb_spec; lia.
Qed.

Lemma nbocc_app a u v : nbocc a (u++v) = nbocc a u + nbocc a v.
Proof.
 induction u; simpl; auto; lia.
Qed.

Lemma nbocc_total_lt u k :
  Forall (fun n => n < k) u ->
  length u = cumul (fun n => nbocc n u) k.
Proof.
 induction u; simpl; intros H.
 - now rewrite cumul_0.
 - inversion_clear H. rewrite cumul_add. rewrite IHu by trivial.
   rewrite cumul_test; simpl; lia.
Qed.

Lemma nbocc_total_le u k :
  Forall (fun n => n <= k) u ->
  length u = cumul (fun n => nbocc n u) (S k).
Proof.
 intros H. apply nbocc_total_lt. eapply Forall_impl; eauto.
 simpl; intros; lia.
Qed.

Lemma nbocc_concat a l :
 nbocc a (concat l) = listsum (map (nbocc a) l).
Proof.
 induction l as [|w l IH]; simpl; auto.
 rewrite nbocc_app. now f_equal.
Qed.

(** Counting letter 0 in [kseq k] leads back to the [f k] fonction.
    [count f a n] is the number of letter [a] in [(f 0) .. (f (pred n))]. *)

Fixpoint count f a n :=
 match n with
 | 0 => 0
 | S n => count f a n + if f n =? a then 1 else 0
 end.

Lemma count_nbocc f a n : count f a n = nbocc a (take n f).
Proof.
 induction n. simpl; auto. rewrite take_S.
 rewrite nbocc_app. simpl. now f_equal.
Qed.

Lemma count_subid f a n : count f a n <= n.
Proof.
 induction n; simpl; trivial. case Nat.eqb_spec; lia.
Qed.

Lemma count_mono f a n m : n <= m -> count f a n <= count f a m.
Proof.
 induction 1; trivial. simpl. lia.
Qed.

Lemma count_0 f a n :
  count f a n = 0 <-> (forall p, p<n -> f p <> a).
Proof.
 split.
 - induction n; simpl; try lia. intros H p Hp.
   inversion_clear Hp.
   + intros E. rewrite E, Nat.eqb_refl in H. lia.
   + apply IHn; try lia.
 - induction n; simpl; trivial. intros H.
   rewrite IHn by (intros p Hp; apply H; lia).
   case Nat.eqb_spec; try lia. intros E. specialize (H n). lia.
Qed.

Lemma count_flat f a n m :
  n <= m -> count f a n = count f a m ->
  forall p, n<=p<m -> f p <> a.
Proof.
 induction 1. lia.
 simpl. intros E p (Hp,Hp'). apply (count_mono f a) in H.
 inversion_clear Hp'.
 - intros E'. rewrite E', Nat.eqb_refl in E. lia.
 - apply IHle; lia.
Qed.

Lemma f_count_0 k n : k<>0 -> count (kseq k) 0 n + f k n = n.
Proof.
 induction n.
 - easy.
 - simpl. intros Hk.
   rewrite kseq_bounded_rank.
   unfold bounded_rank.
   destruct (f_step k n) as [E|E].
   + rewrite E. rewrite flat_rank_0 in E. rewrite E. simpl. lia.
   + rewrite E. rewrite step_rank_nz in E.
     destruct (rank k n) as [[|r]|]; simpl; try easy;
       destruct k; simpl; auto; try lia.
Qed.

(** Similarly, counting all letters above [p] leads to [(f k)^^p],
    the p-iterate of [f k]. *)

Fixpoint count_above f a n :=
 match n with
 | 0 => 0
 | S n => count_above f a n + if a <=? f n then 1 else 0
 end.

Lemma fs_count_above k p n :
  p <= k -> (f k ^^p) n = count_above (kseq k) p n.
Proof.
 intros Hp.
 induction n.
 - simpl. apply fs_k_0.
 - simpl. rewrite kseq_bounded_rank.
   unfold bounded_rank.
   destruct (fs_step k p n) as [E|E].
   + rewrite E. rewrite fs_flat_low_rank in E by lia.
     destruct (rank k n); simpl; try easy.
     red in E. case Nat.leb_spec; lia.
   + rewrite E. rewrite fs_nonflat_high_rank in E by lia.
     destruct (rank k n); simpl in *; case Nat.leb_spec; lia.
Qed.

Lemma count_above_S f p n :
 count_above f p n = count f p n + count_above f (S p) n.
Proof.
 induction n; cbn -[Nat.leb]; auto. rewrite IHn.
 do 2 case Nat.leb_spec; case Nat.eqb_spec; try lia.
Qed.

(** Particular case : p=k *)

Lemma count_above_kseq_k k n :
  count_above (kseq k) k n = count (kseq k) k n.
Proof.
 induction n; simpl; auto.
 rewrite kseq_bounded_rank. unfold bounded_rank.
 destruct (rank k n); simpl in *; case Nat.leb_spec; case Nat.eqb_spec; lia.
Qed.

Lemma fs_count_k k n : (f k ^^k) n = count (kseq k) k n.
Proof.
 rewrite fs_count_above by lia.
 apply count_above_kseq_k.
Qed.


(** Full decomposition of any prefix of kword, then kseq (used in Lim) *)

Definition kwords k (l:list nat) : word := concat (map (kword k) l).

Lemma kwords_singl k n : kwords k [n] = kword k n.
Proof.
 unfold kwords. simpl. now apply app_nil_r.
Qed.

Lemma kwords_app k l l' : kwords k (l++l') = kwords k l ++ kwords k l'.
Proof.
 unfold kwords. now rewrite map_app, concat_app.
Qed.

Lemma kwords_cons k a l : kwords k (a::l) = kword k a ++ kwords k l.
Proof.
 change (a::l) with ([a]++l). now rewrite kwords_app, kwords_singl.
Qed.

Lemma ksubst_kwords k l :
 apply (ksubst k) (kwords k l) = kwords k (map S l).
Proof.
 induction l; simpl; auto.
 now rewrite !kwords_cons, apply_app, IHl, <- kword_S.
Qed.

Lemma decomp_prefix_kword k w n l :
 Prefix w (kword k n) -> l = rev (decomp k (length w)) -> w = kwords k l.
Proof.
 revert w l. induction n as [n IH] using lt_wf_ind.
 intros w l P.
 destruct (Nat.le_gt_cases n (S k)).
 - clear IH. rewrite kword_low in * by trivial.
   destruct (Prefix_cons_inv _ _ _ P) as [->|(w' & E' & P')].
   + simpl. now intros ->.
   + assert (LE := Prefix_len _ _ P'). rewrite seq_length in LE.
     apply Prefix_seq in P'.
     rewrite E'. simpl length. set (p := length w') in *.
     rewrite decomp_low by lia.
     replace (S _ -1) with p by lia. intros ->. simpl.
     rewrite kwords_singl, kword_low, <-P' by lia. trivial.
 - assert (P' := P). destruct P' as ([|a u] & E).
   + rewrite app_nil_r in E. rewrite E. rewrite kword_len.
     replace (decomp k (A k n)) with [n].
     2:{ symmetry; apply decomp_carac; try constructor; simpl; auto. }
     intros ->. simpl. now rewrite kwords_singl.
   + assert (LT : length w < A k n).
     { rewrite <- kword_len, <- E, app_length. simpl. lia. }
     clear  E.
     destruct n; [lia|].
     rewrite kword_alt in P by lia.
     apply Prefix_app in P. destruct P as [P|(w' & -> & P)].
     * apply (IH n); auto.
     * rewrite app_length, kword_len in *.
       rewrite Nat.add_comm, decomp_plus_A by (simpl in LT; lia).
       rewrite rev_app_distr. intros ->. rewrite kwords_app.
       simpl. f_equal. now rewrite kwords_singl.
       apply (IH (n-k)); auto. lia.
Qed.

Lemma decomp_prefix_kseq k n :
 take n (kseq k) = kwords k (rev (decomp k n)).
Proof.
 assert (H := invA_spec k n). set (m := invA k n) in *.
 assert (H' : n <= A k (S m)) by lia. clear H. clearbody m.
 apply (decomp_prefix_kword _ _ (S m)).
 - apply Prefix_nth. intros p a. rewrite take_length. intros LT.
   rewrite take_nth by trivial.
   apply kseq_alt; lia.
 - now rewrite take_length.
Qed.

Lemma renorm_kwords k l :
 Delta k l -> kwords k (rev (renorm k l)) = kwords k (rev l).
Proof.
 unfold renorm.
 generalize (Nat.le_refl (length l)). generalize (length l) at 2 3.
 intro n. revert l.
 induction n as [[|n] IH] using lt_wf_ind; intros l Hl D.
 - now destruct l.
 - destruct l as [|i l]; simpl in *; trivial.
   apply Delta_inv in D.
   destruct (renorm_loop k l n) as [|a l'] eqn:E.
   + simpl. rewrite kwords_app.
     rewrite <- (IH n); trivial; try lia. now rewrite E.
   + case Nat.eqb_spec; intros.
     * rewrite IH; try lia.
       2:{ change (length (S a :: l')) with (length (a::l')).
           rewrite <- E. rewrite renorm_loop_length; lia. }
       2:{ apply Delta_S_cons. rewrite <- E.
           apply renorm_loop_delta; trivial. lia. }
       subst a. simpl. rewrite !kwords_app, !kwords_singl.
       rewrite kword_alt by lia.
       replace (i+k-k) with i by lia. rewrite <- app_ass. f_equal.
       rewrite <- (kwords_singl k (i+k)), <- kwords_app.
       change (_++_) with (rev (i+k::l')). rewrite <- E.
       apply IH; trivial; try lia.
     * rewrite <- E. simpl. rewrite !kwords_app. f_equal.
       apply IH; trivial; lia.
Qed.

Lemma prefix_kseq_laxdecomp k n l :
 DeltaRev k l -> sumA k l = n -> take n (kseq k) = kwords k l.
Proof.
 rewrite <- Delta_rev. rewrite <- (rev_involutive l) at 2 3.
 rewrite sumA_rev. intros D E.
 rewrite <- renorm_kwords by trivial.
 rewrite decomp_prefix_kseq. f_equal. f_equal.
 apply decomp_carac. now apply renorm_delta. now rewrite renorm_sum.
Qed.

Lemma count_kseq_decomp k n a :
 count (kseq k) a n =
  listsum (map (fun m => nbocc a (kword k m)) (decomp k n)).
Proof.
 rewrite count_nbocc, decomp_prefix_kseq. unfold kwords.
 rewrite nbocc_concat. now rewrite map_map, map_rev, listsum_rev.
Qed.

(** Occurrences of letters when applying ksubst *)

Lemma nbocc_ksubst k : k<>0 ->
 let s := apply (ksubst k) in
 forall w,
 nbocc 0 (s w) = nbocc k w /\
 nbocc k (s w) = nbocc (k-1) w + nbocc k w /\
 forall p, p<k-1 -> nbocc (S p) (s w) = nbocc p w.
Proof.
 induction w; simpl.
 - repeat split; lia.
 - unfold s in *. simpl. rewrite !nbocc_app.
   destruct IHw as (IHw0 & IHwk & IHw).
   rewrite IHw0, IHwk. repeat split.
   + unfold ksubst. case Nat.eqb_spec; simpl; try lia.
     case Nat.eqb_spec; simpl; try lia.
   + unfold ksubst. case Nat.eqb_spec; try lia.
     * intros ->. cbn -[Nat.eqb]. rewrite Nat.eqb_refl.
       do 2 (case Nat.eqb_spec; try lia).
     * intros N. case Nat.eqb_spec; try lia.
       { intros ->. replace (S (k-1)) with k by lia. simpl.
         rewrite Nat.eqb_refl. lia. }
       { intros N'. cbn -[Nat.eqb]. case Nat.eqb_spec; try lia. }
   + intros p Hp. rewrite nbocc_app. rewrite (IHw p Hp).
     unfold ksubst. case Nat.eqb_spec; try lia.
     * intros ->. cbn -[Nat.eqb].
       do 3 (case Nat.eqb_spec; try lia).
     * intros N. simpl. lia.
Qed.

(* In [napply] of [ksubst], the initial letter doesn't matter much :
   low letters become [k] after some rounds of [ksubst], while
   unexpected letters stay large. *)

Lemma napply_ksubst_shift k p n : p+n <= k \/ k < p ->
 napply (ksubst k) n [p] = [p+n].
Proof.
 revert p.
 induction n; simpl; intros.
 - f_equal. lia.
 - rewrite app_nil_r. unfold ksubst at 2.
   case Nat.eqb_spec; try lia. intros. rewrite IHn. f_equal; lia. lia.
Qed.

Lemma napply_ksubst_is_kword k p n : p <= k -> k <= n+p ->
 napply (ksubst k) n [p] = kword k (n+p-k).
Proof.
 intros. replace n with ((n+p-k)+(k-p)) by lia.
 rewrite napply_add, napply_ksubst_shift by lia.
 unfold kword; f_equal. lia. f_equal; lia.
Qed.

(** We hence have an easy bound on lengths of n-iterates of ksubst on
   single letters. *)

Definition NapplySizeBound s n N :=
  forall a:letter, length (napply s n [a]) <= N.

Lemma Bound_A k n : NapplySizeBound (ksubst k) n (A k n).
Proof.
 unfold NapplySizeBound. intros.
 destruct (Nat.le_gt_cases a k).
 - destruct (Nat.le_gt_cases k (n+a)).
   + rewrite napply_ksubst_is_kword by lia. rewrite kword_len.
     apply A_mono. lia.
   + rewrite napply_ksubst_shift by lia. simpl. apply A_nz.
 - rewrite napply_ksubst_shift by lia. simpl. apply A_nz.
Qed.

(** Counting occurrences of [k] and [0] in [kword] *)

Lemma nbocc_notin x l : ~In x l -> nbocc x l = 0.
Proof.
 induction l; simpl; trivial.
 intros H. apply Decidable.not_or in H.
 case Nat.eqb_spec; try lia. intros. now rewrite IHl.
Qed.

Lemma nbocc_k_kword k n : nbocc k (kword k n) = A k (n-k).
Proof.
 induction n as [n IH] using lt_wf_ind.
 destruct (Nat.le_gt_cases n k).
 - rewrite kword_low by lia. simpl.
   rewrite Nat.eqb_refl, nbocc_notin.
   2:{ rewrite in_seq; lia. }
   now replace (n-k) with 0 by lia.
 - destruct n; try lia.
   rewrite kword_alt, nbocc_app by lia.
   rewrite IH by lia.
   rewrite IH by lia.
   now replace (S n - k) with (S (n-k)) by lia.
Qed.

Lemma nbocc_0_kword k n : k<>0 -> nbocc 0 (kword k (S n)) = A k (n-k).
Proof.
 intros Hk.
 induction n as [n IH] using lt_wf_ind.
 destruct (Nat.le_gt_cases (S n) k).
 - rewrite kword_low by lia. simpl.
   rewrite nbocc_notin by (rewrite in_seq; lia).
   case Nat.eqb_spec; try lia.
   now replace (n-k) with 0 by lia.
 - destruct n; try lia.
   rewrite kword_alt, nbocc_app by lia.
   rewrite IH by lia.
   destruct (Nat.le_gt_cases (S n) k).
   + replace (S n - k) with 0 by lia. replace (n-k) with 0 by lia. simpl.
     case Nat.eqb_spec; try lia.
   + replace (S n - k) with (S (n-k)) by lia.
     rewrite IH by lia. now simpl.
Qed.


(* Special case k=2

 0 -> 1
 1 -> 2
 2 -> 20

 Occurrence matrix :

 001
 100
 011

*)

Lemma nbocc_ksubst2 w :
 let s := apply (ksubst 2) in
 nbocc 0 (s w) = nbocc 2 w /\
 nbocc 1 (s w) = nbocc 0 w /\
 nbocc 2 (s w) = nbocc 1 w + nbocc 2 w.
Proof.
 assert (H:2<>0) by lia.
 destruct (nbocc_ksubst 2 H w) as (H0 & H1 & Hp). repeat split; trivial.
 apply Hp; lia.
Qed.

Definition tripleocc w := (nbocc 0 w, nbocc 1 w, nbocc 2 w).

Definition occurmatrix '(x,y,z) : nat*nat*nat := (z,x,y+z).

Lemma nbocc_ksubst2_bis w :
 tripleocc (apply (ksubst 2) w) = occurmatrix (tripleocc w).
Proof.
 unfold tripleocc.
 now destruct (nbocc_ksubst2 w) as (-> & -> & ->).
Qed.

Lemma len_nbocc_012 w :
  Forall (fun a => a <= 2) w ->
  length w = nbocc 0 w + nbocc 1 w + nbocc 2 w.
Proof.
 intros. rewrite nbocc_total_le with (k:=2); simpl; auto; lia.
Qed.

Lemma len_ksubst2 w :
 length (apply (ksubst 2) w) = length w + nbocc 2 w.
Proof.
 induction w; simpl; auto.
 rewrite app_length, IHw.
 unfold ksubst at 1.
 case Nat.eqb_spec; simpl; lia.
Qed.

(* Special case k=3

 0 -> 1
 1 -> 2
 2 -> 3
 3 -> 30

 Occurrence matrix :

 0001
 1000
 0100
 0011

*)

Lemma nbocc_ksubst3 w :
 let s := apply (ksubst 3) in
 nbocc 0 (s w) = nbocc 3 w /\
 nbocc 1 (s w) = nbocc 0 w /\
 nbocc 2 (s w) = nbocc 1 w /\
 nbocc 3 (s w) = nbocc 2 w + nbocc 3 w.
Proof.
 assert (H:3<>0) by lia.
 destruct (nbocc_ksubst 3 H w) as (H0 & H1 & Hp). repeat split; trivial.
 apply Hp; lia.
 apply Hp; lia.
Qed.

Definition fourocc w := (nbocc 0 w, nbocc 1 w, nbocc 2 w, nbocc 3 w).

Definition occurmatrix4 '(x,y,z,t) : nat*nat*nat*nat := (t,x,y,z+t).

Lemma nbocc_ksubst3_bis w :
 fourocc (apply (ksubst 3) w) = occurmatrix4 (fourocc w).
Proof.
 unfold fourocc.
 now destruct (nbocc_ksubst3 w) as (-> & -> & -> & ->).
Qed.

Lemma len_nbocc_0123 w :
  Forall (fun a => a <= 3) w ->
  length w = nbocc 0 w + nbocc 1 w + nbocc 2 w + nbocc 3 w.
Proof.
 intros. rewrite nbocc_total_le with (k:=3); simpl; auto; lia.
Qed.

Lemma len_ksubst3 w :
 length (apply (ksubst 3) w) = length w + nbocc 3 w.
Proof.
 induction w; simpl; auto.
 rewrite app_length, IHw.
 unfold ksubst at 1.
 case Nat.eqb_spec; simpl; lia.
Qed.

(* From a Prefix of napply of a word to a prefix of napply of a letter *)

Lemma napply_prefix s n u v :
  NoErase s -> v<>[] ->
  Prefix u (napply s n v) ->
  exists w t a,
    Prefix (w++[a]) v /\ u = napply s n w ++ t /\ Prefix t (napply s n [a]).
Proof.
 intros NE. revert u.
 induction v; try easy.
 - intros u _. rewrite napply_cons. intros Pr.
   apply Prefix_app in Pr. destruct Pr as [Pr|(u' & E & Pr)].
   + exists [], u, a. rewrite napply_nil. simpl. split; auto. now exists v.
   + destruct (list_eq_dec Nat.eq_dec v []) as [->|NE'].
     * rewrite napply_nil in Pr. apply Prefix_nil in Pr. subst u'.
       rewrite app_nil_r in E.
       exists [], u, a. rewrite napply_nil.
       repeat split; subst; auto using Prefix_id.
     * destruct (IHv u' NE' Pr) as (w & t & b & Hv & E' & Ht).
       exists (a::w), t, b. repeat split; auto.
       { simpl. now apply Prefix_cons. }
       { now rewrite napply_cons, app_ass, <- E', <- E. }
Qed.

(** Saari's Lemma 4 : decomposition of a prefix of s^n(a),
    leaving alone a final part whose size is below a certain threshold *)

Lemma Saari_lemma4 s a n w G M1 MG : G<>0 -> n<>0 ->
 NapplySizeBound s 1 M1 -> NapplySizeBound s G MG ->
 NoErase s ->
 Prefix w (napply s n [a]) ->
 exists l : list (nat * word), exists z,
  w = concat (map (fun '(ni,ui) => napply s ni ui) l) ++ z
  /\ Forall (fun '(ni,ui) => length ui <= M1 /\ G <= ni < n) l
  /\ DeltaRev 1 (map fst l)
  /\ length z <= MG.
Proof.
 intros HG. revert a w.
 induction n as [n IH] using lt_wf_ind.
 intros a w Hn B1 BG NE Pr.
 destruct (Nat.le_gt_cases n G).
 - exists []. exists w. simpl. repeat split; auto. constructor.
   apply Prefix_len in Pr.
   etransitivity; [apply Pr|]. red in BG.
   rewrite <- (BG a). now apply napply_mono.
 - destruct n as [|n]; try easy.
   simpl in Pr. rewrite app_nil_r in Pr.
   destruct (napply_prefix s n w (s a) NE (NE a) Pr)
     as (w1 & w2 & b & H1 & H2 & H3).
   destruct (IH n (Nat.lt_succ_diag_r n) b w2)
     as (l & z & EQ & F & D & LE); auto; try lia.
   exists ((n,w1)::l), z; repeat split; auto.
   + simpl. now rewrite app_ass, <-EQ.
   + constructor; try split; auto; try lia.
     * rewrite <- (B1 a). simpl. rewrite app_nil_r.
       apply Prefix_len in H1. rewrite app_length in H1. simpl in H1. lia.
     * clear -F. rewrite Forall_forall in *.
       intros (m,u) IN. apply F in IN. lia.
   + simpl. apply DeltaRev_alt. split; auto.
     intros y. rewrite in_map_iff. intros ((m,y') & <- & IN). simpl.
     rewrite Forall_forall in F. apply F in IN. lia.
Qed.

(* Same idea in a simpler version (decompose in letters instead of words).
   Should be enough for ksubst *)

Definition Reachable s a b := exists n, In b (napply s n [a]).

Lemma Reachable_trans s a b c :
  Reachable s a b -> Reachable s b c -> Reachable s a c.
Proof.
 intros (n,Hb) (m,Hc). exists (m+n). rewrite napply_add.
 destruct (in_split _ _ Hb) as (u & v & ->).
 rewrite napply_app, napply_cons, !in_app_iff. intuition.
Qed.

Lemma Saari_lemma4_bis s a n w G MG : G<>0 -> n<>0 ->
 NapplySizeBound s G MG ->
 NoErase s ->
 Prefix w (napply s n [a]) ->
 exists l : list (nat * letter), exists z,
  w = concat (map (fun '(ni,ui) => napply s ni [ui]) l) ++ z
  /\ Forall (fun '(ni,ui) => G <= ni /\ Reachable s a ui) l
  /\ length z <= MG.
Proof.
 intros HG. revert a w.
 induction n as [n IH] using lt_wf_ind.
 intros a w Hn BG NE Pr.
 destruct (Nat.le_gt_cases n G).
 - exists []. exists w. simpl. repeat split; auto.
   apply Prefix_len in Pr.
   etransitivity; [apply Pr|]. red in BG.
   rewrite <- (BG a). now apply napply_mono.
 - destruct n as [|n]; try easy.
   simpl in Pr. rewrite app_nil_r in Pr.
   destruct (napply_prefix s n w (s a) NE (NE a) Pr)
     as (w1 & w2 & b & H1 & H2 & H3).
   destruct (IH n (Nat.lt_succ_diag_r n) b w2)
     as (l & z & EQ & F & LE); auto; try lia. clear IH.
   exists (map (fun u => (n,u)) w1 ++ l), z; repeat split; auto.
   + simpl. rewrite H2, EQ. rewrite <- app_ass. f_equal.
     now rewrite map_app, map_map, napply_concat, concat_app.
   + apply Forall_app; split.
     * rewrite Forall_forall. intros (p,c).
       rewrite in_map_iff. intros (x & [= <- <-] & IN). split. lia.
       exists 1. simpl. rewrite app_nil_r. destruct H1 as (w3 & <-).
       rewrite !in_app_iff; intuition.
     * rewrite Forall_forall in *. intros (p,c) IN.
       destruct (F (p,c) IN). split; trivial. eapply Reachable_trans; eauto.
       exists 1. simpl. rewrite app_nil_r. destruct H1 as (w3 & <-).
       rewrite !in_app_iff; intuition.
Qed.

Lemma Reachable_ksubst k p :
  p <= k -> forall q, Reachable (ksubst k) p q <-> q <= k.
Proof.
 intros Hp q. split.
 - intros (n,H).
   assert (F : Forall (fun a => a <= k) [p]) by repeat (constructor; try lia).
   apply (napply_ksubst_letters _ n) in F.
   rewrite Forall_forall in F. now apply F.
 - intros Hq.
   apply Reachable_trans with k.
   + exists (k-p). rewrite napply_ksubst_shift by lia.
     replace (p+(k-p)) with k; simpl; lia.
   + apply Reachable_trans with 0.
     * exists 1. simpl. unfold ksubst. rewrite Nat.eqb_refl. simpl; intuition.
     * exists q. rewrite napply_ksubst_shift by lia. simpl. lia.
Qed.

Lemma Saari_lemma4_ksubst k n w G : G<>0 -> n<>0 ->
 Prefix w (kword k n) ->
 exists l : list nat, exists z,
  w = concat (map (kword k) l) ++ z
  /\ Forall (Nat.le G) l
  /\ length z <= A k (k+G).
Proof.
 intros HG Hn Pref.
 destruct (Saari_lemma4_bis (ksubst k) k n w (k+G) (A k (k+G))) as
  (l & z & E & F & LE); trivial; try lia.
 - apply Bound_A.
 - apply ksubst_noerase.
 - exists (map (fun '(ni,ui) => ni+ui-k) l); exists z; repeat split; trivial.
   + rewrite E. f_equal. f_equal.
     rewrite map_map. simpl. apply map_ext_in.
     intros (ni,ui) IN.
     rewrite Forall_forall in F. destruct (F _ IN) as (U,V).
     rewrite Reachable_ksubst in V; try lia.
     rewrite napply_ksubst_is_kword; trivial; try lia.
   + rewrite Forall_map.
     rewrite Forall_forall in *. intros (p,c) IN.
     destruct (F _ IN) as (U,V).
     rewrite Reachable_ksubst in V; try lia.
Qed.

Lemma firstn_Prefix n l : Prefix (firstn n l) l.
Proof.
 exists (skipn n l). apply firstn_skipn.
Qed.

Lemma nth_firstn {A} n m (l:list A) a :
 m < n -> nth m (firstn n l) a = nth m l a.
Proof.
 revert l n.
 induction m; destruct n, l; simpl; trivial; try lia.
 intros. apply IHm. lia.
Qed.

Lemma kseq_take k n p : n <= A k p -> take n (kseq k) = firstn n (kword k p).
Proof.
 intros LE.
 apply take_carac.
 - rewrite firstn_length, kword_len. lia.
 - intros m a LT.
   rewrite nth_firstn by lia. symmetry. apply kseq_alt. lia.
Qed.

Lemma count_kseq k n p :
  n <= A k p ->
  count (kseq k) 0 n = nbocc 0 (firstn n (kword k p)).
Proof.
 intros LE.
 rewrite count_nbocc. f_equal. now apply kseq_take.
Qed.

(** Is there a 0 at position n in [kseq k] ?
    If so, there's a k at the previous position. *)

Definition is_k0 k n := (kseq k n =? 0).

Lemma rank_0_pred k n : rank k n = Some 0 -> bounded_rank k (pred n) = k.
Proof.
 unfold rank. destruct (decomp k n) as [|r l] eqn:E; try easy.
 intros [= ->].
 unfold bounded_rank, rank.
 assert (D := decomp_delta k n).
 rewrite E in D.
 rewrite (@decomp_carac k (pred n) l).
 2:{ now apply Delta_inv in D. }
 2:{ now rewrite <- (decomp_sum k n), E. }
 destruct l as [|r' l']; trivial. simpl.
 inversion_clear D. lia.
Qed.

Lemma k0_pred_k k n : kseq k n = 0 -> kseq k (pred n) = k.
Proof.
 rewrite !kseq_bounded_rank.
 unfold bounded_rank at 1, omin.
 destruct (Nat.eq_dec k 0) as [->|Hk].
 - unfold bounded_rank, omin. do 2 destruct rank; lia.
 - destruct rank as [r|] eqn:E; try lia. intros Hr.
   replace r with 0 in * by lia. now apply rank_0_pred.
Qed.

(** Given two consecutive prefixes of [kseq], one of the two is
    a [ksubst] of a smaller prefix. *)

Lemma kseq_take_inv k n : k<>0 ->
  take (n + if is_k0 k n then 1 else 0) (kseq k) =
  apply (ksubst k) (take (f k n) (kseq k)).
Proof.
 intros Hk.
 set (l := rev (decomp k n)).
 set (l' := map pred l).
 assert (D' : DeltaRev k l').
 { unfold l', l. rewrite map_rev, DeltaRev_rev.
   apply Delta_map with (S k). lia. apply decomp_delta. }
 assert (E : sumA k l' = f k n).
 { unfold l', l. rewrite map_rev, sumA_rev. symmetry. apply f_decomp. }
 rewrite (prefix_kseq_laxdecomp k (f k n) l') by trivial.
 rewrite ksubst_kwords; auto.
 apply prefix_kseq_laxdecomp.
 - unfold l', l. rewrite map_map, map_rev, DeltaRev_rev.
   apply Delta_map with (S k). lia. apply decomp_delta.
 - unfold l', l. clear -Hk. rewrite map_map, map_rev, sumA_rev.
   destruct (decomp k n) as [|r l] eqn:E.
   + simpl. rewrite <- (decomp_sum k n), E. simpl.
     unfold is_k0; rewrite kseq_bounded_rank. unfold bounded_rank.
     replace (rank k 0) with (@None nat).
     2:{symmetry. now rewrite rank_none. }
     simpl. case Nat.eqb_spec; lia.
   + unfold is_k0. rewrite kseq_bounded_rank. unfold bounded_rank.
     unfold rank. rewrite E. simpl omin.
     case Nat.eqb_spec; intros.
     * replace r with 0 in * by lia. simpl.
       rewrite map_ext_in with (g:=id), map_id.
       2:{ intros a Ha. unfold id.
           assert (D := decomp_delta k n).
           rewrite E in D. apply Delta_nz' in D; try lia.
           assert (a<>0); try lia. now intros ->. }
       rewrite <- (decomp_sum k n), E. simpl. lia.
     * rewrite map_ext_in with (g:=id), map_id.
       now rewrite <- E, decomp_sum.
       assert (D := decomp_delta k n).
       rewrite E in D. apply Delta_nz in D; try lia.
       intros a Ha. unfold id. assert (a<>0); try lia. now intros ->.
Qed.

(** Shuo / Steiner proof : the partial sums of kseq grow with k.
    Applications :
    - the count of letter k decreases with k
    - the count of letter 0 decreases with k
*)

Lemma ksubstk_len k n : n <= k -> length (ksubstk k n) = S n.
Proof.
 intros H. rewrite ksubstk_alt by trivial. simpl. f_equal. apply seq_length.
Qed.

Lemma PrefixSeq_alt s a :
  NoErase s -> Prolong s a ->
  forall u,
    PrefixSeq u (subst2seq s a) <-> Prefix u (napply s (length u) [a]).
Proof.
 intros NE PR u. unfold PrefixSeq.
 split.
 - generalize (length u). intros n Hu.
   rewrite Prefix_nth. intros m b Hm.
   subst u. rewrite take_length in Hm.
   rewrite take_nth by trivial.
   rewrite <- subst2seq_indep; trivial; lia.
 - set (n := length u). intros Hu.
   symmetry. apply take_carac; trivial.
   intros m b Hm. rewrite Prefix_nth in Hu.
   rewrite Hu by trivial. symmetry. apply subst2seq_indep; trivial. lia.
Qed.

Lemma PrefixSeq_alt' s a :
  NoErase s -> Prolong s a ->
  forall u,
    PrefixSeq u (subst2seq s a) <-> exists m, Prefix u (napply s m [a]).
Proof.
 intros NE PR u. rewrite PrefixSeq_alt by trivial.
 split.
 - intros H. now exists (length u).
 - intros (m,H). destruct (Nat.le_gt_cases m (length u)) as [L|L].
   + eapply Prefix_trans; eauto. apply napply_prefix_mono; trivial.
   + eapply Prefix_Prefix; eauto.
     * apply Nat.lt_le_incl, noerase_prolong_napply_len; trivial.
     * apply napply_prefix_mono; trivial; lia.
Qed.

Lemma PrefixSeq_apply s a :
  NoErase s -> Prolong s a ->
  forall u,
   PrefixSeq u (subst2seq s a) ->
   PrefixSeq (apply s u) (subst2seq s a).
Proof.
  intros NE PR u.
  rewrite !PrefixSeq_alt' by trivial.
  intros (m,(u',E)). exists (S m).
  rewrite napply_alt, <- E, apply_app. now exists (apply s u').
Qed.

Lemma PrefixSeq_napply s a n :
  NoErase s -> Prolong s a ->
  forall u,
   PrefixSeq u (subst2seq s a) ->
   PrefixSeq (napply s n u) (subst2seq s a).
Proof.
  intros NE PR.
  induction n; trivial.
  intros u Hu. simpl. apply IHn, PrefixSeq_apply; trivial.
Qed.

Lemma ksubst_prefix k u :
 PrefixSeq u (kseq k) -> PrefixSeq (apply (ksubst k) u) (kseq k).
Proof.
  apply PrefixSeq_apply. apply ksubst_noerase. apply ksubst_prolong.
Qed.

Lemma ksubstk_prefix k u :
 PrefixSeq u (kseq k) -> PrefixSeq (apply (ksubstk k) u) (kseq k).
Proof.
  rewrite <- napply_1.
  rewrite napply_ksubstk. apply PrefixSeq_napply.
  apply ksubst_noerase.
  apply ksubst_prolong.
Qed.

Definition IncrFun f := forall p, f p < f (S p).

Lemma incr_function_bounds f : IncrFun f ->
  forall n, f 0 <= n -> exists p, f p <= n < f (S p).
Proof.
 intros Hf.
 induction n; intros H.
 - exists 0. split; trivial. specialize (Hf 0). lia.
 - destruct (Nat.le_gt_cases (f 0) n).
   + destruct IHn as (p & Hp); trivial.
     destruct (Nat.eq_dec (S n) (f (S p))) as [E|NE].
     * exists (S p). split. lia. rewrite E. apply Hf.
     * exists p. lia.
   + exists 0. split; try lia. replace (S n) with (f 0) by lia. apply Hf.
Qed.

Lemma incr_function_bounds' f : IncrFun f ->
  forall n, f 0 < n -> exists p, f p < n <= f (S p).
Proof.
 intros Hf n H0.
 destruct n. lia.
 destruct (incr_function_bounds f Hf n) as (p,Hp); try lia.
 exists p. lia.
Qed.

(** Where is the p-th letter k in [kseq k] ?
    We count occurrences from 0 : the 0-th letter k is at position 0 *)

Definition positionk k p := length (apply (ksubstk k) (take p (kseq k))).

Record IsPosition (f:sequence)(a:letter)(pos:nat->nat) :=
  { PosIncr : IncrFun pos;
    PosCorrect : forall p, f (pos p) = a;
    PosComplete : forall n, f n = a -> exists p, n = pos p }.

Lemma positionk_S k p : positionk k (S p) = positionk k p + S (kseq k p).
Proof.
 unfold positionk.
 rewrite take_S, apply_app, app_length; simpl.
 now rewrite app_nil_r, ksubstk_len by apply kseq_letters.
Qed.

Lemma kseq_positionk k p : kseq k (positionk k p) = k.
Proof.
 rewrite <- (take_nth (kseq k) (positionk k (S p)) _ k).
 2:{ rewrite positionk_S; lia. }
 set (u := take (S p) (kseq k)).
 assert (Hu : PrefixSeq u (kseq k)).
 { red. unfold u. f_equal. now rewrite take_length. }
 apply ksubstk_prefix in Hu. red in Hu. unfold u at 2 in Hu.
 fold (positionk k (S p)) in Hu. rewrite <- Hu.
 clear Hu. unfold u. rewrite take_S, apply_app.
 rewrite app_nth2 by (unfold positionk; lia).
 replace (_-_) with 0 by (unfold positionk; lia). simpl.
 now rewrite app_nil_r, ksubstk_alt by apply kseq_letters.
Qed.

Lemma kseq_k_0 k : kseq k 0 = k.
Proof.
  now rewrite kseq_bounded_rank.
Qed.

Lemma count_k_nz k n : 0 < n -> 0 < count (kseq k) k n.
Proof.
 induction n.
 - lia.
 - intros _. destruct n; simpl in *; try lia.
   rewrite kseq_k_0, Nat.eqb_refl. lia.
Qed.

Lemma nbocc_ksubstk k u :
  Forall (fun a => a <= k) u ->
  nbocc k (apply (ksubstk k) u) = length u.
Proof.
 induction u; trivial.
 simpl. intros Hu. inversion_clear Hu.
 rewrite nbocc_app, IHu by trivial.
 rewrite ksubstk_alt by trivial. simpl.
 rewrite Nat.eqb_refl. rewrite nbocc_notin; try lia.
 rewrite in_seq. lia.
Qed.

Lemma take_kseq_letters k n :
  Forall (fun a => a <= k) (take n (kseq k)).
Proof.
 induction n.
 - unfold take. simpl. constructor.
 - rewrite take_S. apply Forall_app. split; trivial.
   repeat constructor. apply kseq_letters.
Qed.

Lemma countk_positionk k p :
 count (kseq k) k (positionk k p) = p.
Proof.
 rewrite count_nbocc.
 set (u := take p (kseq k)).
 assert (Hu : PrefixSeq u (kseq k)).
 { red. unfold u. f_equal. now rewrite take_length. }
 apply ksubstk_prefix in Hu. red in Hu. unfold u at 2 in Hu.
 fold (positionk k p) in Hu. unfold letter in Hu. rewrite <- Hu.
 rewrite nbocc_ksubstk. unfold u. apply take_length.
 apply take_kseq_letters.
Qed.

Lemma countk_S_positionk k p :
 count (kseq k) k (S (positionk k p)) = S p.
Proof.
 rewrite count_nbocc, take_S, nbocc_app, <- count_nbocc, countk_positionk.
 rewrite kseq_positionk. simpl. rewrite Nat.eqb_refl. lia.
Qed.

Lemma positionk_bounds k n :
  0 < n ->
  exists p, positionk k p < n <= positionk k (S p).
Proof.
 intros. apply incr_function_bounds'; auto. intro. rewrite positionk_S. lia.
Qed.

Lemma positionk_complete k n :
 kseq k n = k -> exists p, n = positionk k p.
Proof.
 destruct (Nat.eq_dec n 0).
 - subst. now exists 0.
 - destruct (positionk_bounds k n) as (p, (Hp, HSp)). lia.
   exists (S p).
   apply Nat.le_lteq in HSp. destruct HSp; trivial.
   exfalso.
   assert (LE : S (positionk k p) <= positionk k (S p)).
   { rewrite positionk_S. lia. }
   set (a := positionk k p) in *.
   set (b := positionk k (S p)) in *.
   assert (E : count (kseq k) k (S a) = count (kseq k) k b).
   { unfold a, b. now rewrite countk_S_positionk, countk_positionk. }
   assert (P := count_flat (kseq k) k (S a) b LE E n). lia.
Qed.

Lemma positionk_is_position k : IsPosition (kseq k) k (positionk k).
Proof.
 constructor.
 - red. intros. rewrite positionk_S. lia.
 - apply kseq_positionk.
 - apply positionk_complete.
Qed.

Lemma positionk_cumul k n :
  positionk k n = n + cumul (kseq k) n.
Proof.
 unfold positionk.
 induction n. trivial.
 rewrite take_S, apply_app, app_length, IHn. simpl.
 rewrite app_nil_r, ksubstk_len by apply kseq_letters. lia.
Qed.

Lemma positionk_bounds' k n p :
  0 < n ->
  p = count (kseq k) k n ->
  positionk k (p-1) < n <= positionk k p.
Proof.
  intros Hn Hp.
  destruct (positionk_bounds k n Hn) as (p' & (U,V)).
  assert (U' := count_mono (kseq k) k _ _ U).
  rewrite countk_S_positionk, <- Hp in U'.
  assert (V' := count_mono (kseq k) k _ _ V).
  rewrite countk_positionk, <- Hp in V'.
  replace p with (S p') by lia. simpl. rewrite Nat.sub_0_r. lia.
Qed.

Lemma cumul_mono f n m : n <= m -> cumul f n <= cumul f m.
Proof.
 induction 1; trivial. simpl. lia.
Qed.

Lemma length_apply_ksubst k m :
  length (apply (ksubst k) (take m (kseq k))) = m + count (kseq k) k m.
Proof.
 induction m; trivial.
 rewrite take_S, apply_app, app_length, IHm. simpl. unfold ksubst.
 case Nat.eqb_spec; simpl; lia.
Qed.

Lemma Prefix_take w n m : n <= m -> Prefix (take n w) (take m w).
Proof.
 intros H.
 apply Prefix_nth. intros p a Hp. rewrite take_length in Hp.
 rewrite !take_nth; trivial; lia.
Qed.

Lemma PrefixSeq_incl w u v :
  length u <= length v ->
  PrefixSeq u w -> PrefixSeq v w -> Prefix u v.
Proof.
 unfold PrefixSeq. intros H -> ->. now apply Prefix_take.
Qed.

Lemma listsum_prefix u v : Prefix u v -> listsum u <= listsum v.
Proof.
 intros (u',<-). rewrite listsum_app. lia.
Qed.

Lemma listsum_ksubst k u :
  listsum (apply (ksubst k) u) + nbocc k u = listsum u + length u.
Proof.
 induction u; trivial.
 simpl. rewrite listsum_app. unfold ksubst at 1.
 case Nat.eqb_spec; simpl; try lia.
Qed.

Lemma nbocc_le_length k u : nbocc k u <= length u.
Proof.
 induction u; simpl; trivial. case Nat.eqb; lia.
Qed.

Lemma listsum_ksubst' k u :
  listsum (apply (ksubst k) u) = listsum u + length u - nbocc k u.
Proof.
 generalize (nbocc_le_length k u) (listsum_ksubst k u). lia.
Qed.

Lemma cumul_kseq_grows k n : 0<n -> cumul (kseq k) n < cumul (kseq (S k)) n.
Proof.
 induction n as [[|n] IH] using lt_wf_ind; [lia|intros _].
 destruct (Nat.eq_dec n 0) as [->|Hn'].
 - simpl. rewrite kseq_bounded_rank. unfold bounded_rank. simpl. lia.
 - destruct (Nat.le_gt_cases k (kseq (S k) n)) as [LE|LT].
   + simpl. specialize (IH n). generalize (kseq_letters k n). lia.
   + assert (Hk : S k <> 0) by lia.
     assert (E := kseq_take_inv (S k) (S n) Hk).
     replace (is_k0 (S k) (S n)) with false in *.
     2:{ unfold is_k0. case Nat.eqb_spec; trivial.
         intros H. apply k0_pred_k in H. simpl in H. lia. }
     rewrite Nat.add_0_r in E.
     set (m := f (S k) (S n)) in *.
     assert (Hm : m < S n) by (apply f_lt; lia).
     assert (Hm0 : 0 < m) by (apply f_nonzero; lia).
     assert (IHm := IH m Hm Hm0).
     set (a := fun k => count (kseq k) k).
     assert (LE : a (S k) m <= a k m).
     { rewrite Nat.le_ngt. intro.
       assert (E1 : m <= positionk k (a k m)) by (apply positionk_bounds'; trivial).
       assert (E2 := positionk_cumul k (a k m)).
       assert (E3 : cumul (kseq k) (a k m) < cumul (kseq (S k)) (a k m)).
       { apply IH. apply Nat.le_lt_trans with m. apply count_subid. lia.
         apply count_k_nz. lia. }
       assert (E4 : cumul (kseq (S k)) (a k m) <=
                    cumul (kseq (S k)) (a (S k) m -1)).
       { apply cumul_mono. lia. }
       assert (E5 := positionk_cumul (S k) (a (S k) m -1)).
       assert (E6 : positionk (S k) (a (S k) m - 1) < m).
       { apply positionk_bounds'; trivial. }
       lia.
     }
     assert (E1 : S n <= length (apply (ksubst k) (take m (kseq k)))).
     { rewrite length_apply_ksubst. fold (a k m).
       transitivity (m + a (S k) m); try lia.
       unfold a. now rewrite <- length_apply_ksubst, <- E, take_length. }
     assert (P : Prefix (take (S n) (kseq k)) (apply (ksubst k) (take m (kseq k)))).
     { apply (PrefixSeq_incl (kseq k)).
       - now rewrite take_length.
       - red. now rewrite take_length.
       - apply ksubst_prefix. red. now rewrite take_length. }
     apply listsum_prefix in P.
     rewrite <- cumul_alt in P.
     eapply Nat.le_lt_trans; [ apply P | ].
     rewrite cumul_alt. unfold letter in E. rewrite E.
     rewrite !listsum_ksubst'.
     generalize (nbocc_le_length k (take m (kseq k))).
     generalize (nbocc_le_length (S k) (take m (kseq (S k)))).
     rewrite <- !cumul_alt, !take_length, <- !count_nbocc.
     fold (a k m). fold (a (S k) m).
     lia.
Qed.

(** Application : counting letter k *)

Lemma positionk_grows k n : positionk k n <= positionk (S k) n.
Proof.
 rewrite !positionk_cumul.
 destruct (Nat.le_gt_cases n 0) as [Hn|Hn].
 - replace n with 0 by lia. trivial.
 - assert (H := cumul_kseq_grows k n Hn). lia.
Qed.

Lemma incr_strmono f :
  (forall p, f p < f (S p)) -> (forall p q, p < q -> f p < f q).
Proof.
 intros H. induction 1; auto. specialize (H m). lia.
Qed.

Lemma incr_mono f :
  (forall p, f p < f (S p)) -> (forall p q, p <= q -> f p <= f q).
Proof.
 intros H. induction 1; auto. specialize (H m). lia.
Qed.

Lemma incr_monoiff f :
  (forall p, f p < f (S p)) -> (forall p q, p < q <-> f p < f q).
Proof.
 intros H p q. split. apply (incr_strmono f H).
 destruct (Nat.lt_trichotomy p q) as [LT|[EQ|GT]]; trivial.
 - subst. lia.
 - apply (incr_strmono f H) in GT. lia.
Qed.

Lemma pos_count0 f a pos :
  IsPosition f a pos ->
  forall n, n <= pos 0 -> count f a n = 0.
Proof.
 intros (P0,P1,P2) n Hn. apply count_0. intros m Hm E.
 destruct (P2 _ E) as (p,Hp).
 assert (pos p < pos 0) by lia.
 generalize (incr_monoiff pos P0 p 0). lia.
Qed.

Lemma pos_count f a pos :
 IsPosition f a pos ->
 forall n p, pos p < n <= pos (S p) -> count f a n = S p.
Proof.
 intros (P0,P1,P2).
 induction n.
 - lia.
 - intros p Hp. simpl.
   destruct (Nat.eq_dec n (pos p)) as [EQ|NE].
   + rewrite EQ at 2. rewrite P1, Nat.eqb_refl, Nat.add_1_r. f_equal.
     destruct (Nat.eq_dec p 0).
     * subst p.
       apply (pos_count0 f a pos); try lia. split; auto.
     * rewrite (IHn (p-1)); try lia.
       rewrite EQ. replace p with (S (p-1)) at 2 3 by lia.
       split. apply P0. easy.
   + assert (Hp2 : pos p < n <= pos (S p)) by lia.
     rewrite (IHn _ Hp2).
     case Nat.eqb_spec; intros E; try lia.
     exfalso.
     destruct (P2 _ E) as (p',Hp').
     rewrite Hp' in Hp2. destruct Hp2 as (Hp3,Hp4).
     apply (incr_monoiff _ P0) in Hp3.
     rewrite Nat.le_ngt, <- (incr_monoiff _ P0), <- Nat.le_ngt in Hp4.
     replace p' with (S p) in *; lia.
Qed.

Lemma gen_pos_count f f' a a' pos pos' :
  IsPosition f a pos ->
  IsPosition f' a' pos' ->
  (forall p, pos p <= pos' p) ->
  forall n, count f' a' n <= count f a n.
Proof.
 intros (P0,P1,P2) (P0',P1',P2') LE.
 induction n as [n IH] using lt_wf_ind.
 destruct (Nat.le_gt_cases n (pos' 0)) as [H0'|H0'].
 replace (count f' a' n) with 0. lia.
 { symmetry. apply count_0. intros p Hp E. destruct (P2' _ E) as (p',E').
   assert (pos' p' < pos' 0) by lia.
   generalize (incr_monoiff pos' P0' p' 0). lia. }
 assert (H0 : pos 0 < n) by (generalize (LE 0); lia).
 destruct (incr_function_bounds' pos P0 n H0) as (p & Hp).
 destruct (incr_function_bounds' pos' P0' n H0') as (p' & Hp').
 replace (count f a n) with (S p).
 2:{ symmetry. apply (pos_count f a pos); try lia. split; auto. }
 replace (count f' a' n) with (S p').
 2:{ symmetry. apply (pos_count f' a' pos'); try lia. split; auto. }
 apply -> Nat.succ_le_mono.
 assert (pos p' < n).
 { apply Nat.le_lt_trans with (pos' p'). apply LE. lia. }
 apply Nat.le_ngt. unfold lt. intros Hpp'.
 generalize (incr_mono pos P0 _ _ Hpp'). lia.
Qed.

Lemma countk_decreases k n :
  count (kseq (S k)) (S k) n <= count (kseq k) k n.
Proof.
  apply (gen_pos_count _ _ _ _ (positionk k) (positionk (S k))).
  - apply positionk_is_position.
  - apply positionk_is_position.
  - apply positionk_grows.
Qed.

Lemma fs_decreases k n :
 (f (S k) ^^ (S k)) n <= (f k ^^ k) n.
Proof.
 rewrite !fs_count_k. apply countk_decreases.
Qed.

(** Let's now count letter 0 *)

(** The substitution [(ksubst k)^(S k)] is also quite interesting :
    its infinite word is also [kseq k], but it produces it by
    blocks starting by all the [k;0] letters. *)

Definition ksubstSk k n := napply (ksubst k) (S k) [n].

Lemma ksubstSk_alt0 k n :
  ksubstSk k n = apply (ksubst k) (apply (ksubstk k) [n]).
Proof.
 unfold ksubstSk, ksubstk. rewrite napply_alt at 1. f_equal. simpl.
 now rewrite !app_nil_r.
Qed.

Lemma napply_ksubstSk k n l :
 napply (ksubstSk k) n l = napply (ksubst k) (n*(S k)) l.
Proof.
 induction n; trivial.
 rewrite napply_alt, IHn.
 simpl Nat.mul. rewrite napply_alt, napply_add.
 set (u := napply _ _ _). clearbody u.
 unfold ksubstSk. now rewrite apply_napply, napply_alt.
Qed.

Lemma ksubstSk_kword k n : n <= k ->
  ksubstSk k n = kword k (S n).
Proof.
 intros H. rewrite ksubstSk_alt0.
 simpl (apply _ [n]). rewrite app_nil_r, ksubstk_kword by trivial.
 now rewrite <- kword_S.
Qed.

Lemma ksubstSk_alt k n : n <= k ->
  ksubstSk k n = k :: seq 0 (S n).
Proof.
 intros. rewrite <- kword_low by lia. now apply ksubstSk_kword.
Qed.

Lemma ksubstSk_len k n : n <= k -> length (ksubstSk k n) = 2+n.
Proof.
 intros. rewrite ksubstSk_kword, kword_len by trivial. rewrite A_base; lia.
Qed.

Lemma nbocc_ksubstSk k u :
  k<>0 ->
  Forall (fun a : nat => a <= k) u ->
  nbocc 0 (apply (ksubstSk k) u) = length u.
Proof.
 intros Hk.
 induction u; trivial.
 simpl. intros Hu. inversion_clear Hu.
 rewrite nbocc_app, IHu by trivial.
 rewrite ksubstSk_alt by trivial. simpl.
 case Nat.eqb_spec; intros; try easy.
 rewrite nbocc_notin; try lia.
 rewrite in_seq; lia.
Qed.

Lemma ksubstSk_prefix k u :
  PrefixSeq u (kseq k) -> PrefixSeq (apply (ksubstSk k) u) (kseq k).
Proof.
 rewrite <- napply_1.
 rewrite napply_ksubstSk. apply PrefixSeq_napply.
 apply ksubst_noerase.
 apply ksubst_prolong.
Qed.

Definition position0 k p := S (length (apply (ksubstSk k) (take p (kseq k)))).

Lemma position0_S k p : position0 k (S p) = position0 k p + kseq k p + 2.
Proof.
 unfold position0.
 rewrite take_S, apply_app, app_length; simpl.
 rewrite app_nil_r, ksubstSk_len by apply kseq_letters. lia.
Qed.

Lemma kseq_position0 k p : kseq k (position0 k p) = 0.
Proof.
 rewrite <- (take_nth (kseq k) (position0 k (S p) - 1) _ k).
 2:{ rewrite position0_S; lia. }
 set (u := take (S p) (kseq k)).
 assert (Hu : PrefixSeq u (kseq k)).
 { red. unfold u. f_equal. now rewrite take_length. }
 apply ksubstSk_prefix in Hu. red in Hu. unfold u at 2 in Hu.
 replace (length _) with (position0 k (S p) - 1) in Hu.
 2:{ unfold position0. lia. }
 rewrite <- Hu.
 clear Hu. unfold u. rewrite take_S, apply_app.
 rewrite app_nth2 by (unfold position0; lia).
 replace (_-_) with 1 by (unfold position0; lia). simpl.
 now rewrite app_nil_r, ksubstSk_alt by apply kseq_letters.
Qed.

Lemma count0_position0 k p :
 k<>0 ->
 count (kseq k) 0 (position0 k p) = p.
Proof.
 intros Hk.
 rewrite count_nbocc.
 set (u := take p (kseq k)).
 assert (Hu : PrefixSeq u (kseq k)).
 { red. unfold u. f_equal. now rewrite take_length. }
 apply ksubstSk_prefix in Hu. red in Hu. unfold u at 2 in Hu.
 unfold position0. rewrite take_S.
 unfold letter in *. rewrite <- Hu.
 rewrite nbocc_app.
 rewrite nbocc_ksubstSk; trivial. 2:{ unfold u. apply take_kseq_letters. }
 unfold u. rewrite take_length.
 change (length _) with (pred (position0 k p)).
 rewrite k0_pred_k by apply kseq_position0.
 simpl. case Nat.eqb_spec; lia.
Qed.

Lemma count0_S_position0 k p :
 k<>0 ->
 count (kseq k) 0 (S (position0 k p)) = S p.
Proof.
 intros Hk.
 rewrite count_nbocc, take_S, nbocc_app, <- count_nbocc, kseq_position0.
 rewrite count0_position0 by trivial. simpl. lia.
Qed.

Lemma position0_bounds k n :
  1 < n ->
  exists p, position0 k p < n <= position0 k (S p).
Proof.
 intros. apply incr_function_bounds'; auto. intro. rewrite position0_S. lia.
Qed.

Lemma position0_complete k n :
 k<>0 ->
 kseq k n = 0 -> exists p, n = position0 k p.
Proof.
 intros Hk.
 destruct (Nat.le_gt_cases n 1).
 - intros E. exists 0. unfold position0. simpl.
   inversion_clear H; trivial. replace n with 0 in * by lia.
   rewrite kseq_k_0 in E. lia.
 - destruct (position0_bounds k n) as (p, (Hp, HSp)). lia.
   exists (S p).
   apply Nat.le_lteq in HSp. destruct HSp; trivial.
   exfalso.
   assert (LE : S (position0 k p) <= position0 k (S p)).
   { rewrite position0_S. lia. }
   set (a := position0 k p) in *.
   set (b := position0 k (S p)) in *.
   assert (E : count (kseq k) 0 (S a) = count (kseq k) 0 b).
   { unfold a, b. now rewrite count0_S_position0, count0_position0. }
   assert (P := count_flat (kseq k) 0 (S a) b LE E n). lia.
Qed.

Lemma position0_is_position k : k<>0 -> IsPosition (kseq k) 0 (position0 k).
Proof.
 intros Hk. constructor.
 - red. intros. rewrite position0_S. lia.
 - apply kseq_position0.
 - intros. now apply position0_complete.
Qed.

Lemma position0_cumul k n :
  position0 k n = 1+2*n + cumul (kseq k) n.
Proof.
 unfold position0.
 induction n; trivial.
 rewrite take_S, apply_app, app_length.
 rewrite <- Nat.add_succ_l, IHn. simpl length.
 rewrite app_nil_r, ksubstSk_len by apply kseq_letters. simpl. lia.
Qed.

Lemma position0_grows k n :
 k<>0 ->
 position0 k n <= position0 (S k) n.
Proof.
 intros Hk.
 rewrite !position0_cumul.
 destruct (Nat.le_gt_cases n 0) as [Hn|Hn].
 - replace n with 0 by lia. trivial.
 - assert (H := cumul_kseq_grows k n Hn). lia.
Qed.

Lemma count_all f a n : (forall m, m<n -> f m = a) -> count f a n = n.
Proof.
 induction n. trivial. intros H.
 simpl. rewrite IHn by intuition. rewrite (H n), Nat.eqb_refl; lia.
Qed.

Lemma count0_decreases k n :
  count (kseq (S k)) 0 n <= count (kseq k) 0 n.
Proof.
 destruct (Nat.eq_dec k 0) as [->|Hk].
 - transitivity n. apply count_subid. rewrite count_all; trivial.
   intros m _. generalize (kseq_letters 0 m). lia.
 - apply (gen_pos_count _ _ _ _ (position0 k) (position0 (S k))).
   + now apply position0_is_position.
   + now apply position0_is_position.
   + intros. now apply position0_grows.
Qed.

Theorem f_grows k n : f k n <= f (S k) n.
Proof.
 destruct (Nat.eq_dec k 0) as [->|Hk].
 - rewrite f_0_div2. rewrite f_1_g. apply g_Sdiv2_le.
 - generalize (count0_decreases k n) (f_count_0 k n) (f_count_0 (S k) n).
   lia.
Qed.

(* TODO: this inequality is actually strict except for a few low n *)


(** Study of suffixes of kword : always exactly (k+1) different suffixes
    of the same length *)

Lemma kword_suffix_cycle k n u :
  Suffix u (kword k n) -> Suffix u (kword k (n+S k)).
Proof.
 intros Su.
 rewrite Nat.add_succ_r, kword_alt by lia. replace (n+k-k) with n by lia.
 now apply Suffix_app_l.
Qed.

Lemma kword_suffix_pcycle k n p u :
  Suffix u (kword k n) -> Suffix u (kword k (n+p*S k)).
Proof.
 intros H.
 induction p.
 - simpl. now rewrite Nat.add_0_r.
 - replace (n+S p * S k) with ((n+p*S k)+S k) by lia.
   now apply kword_suffix_cycle.
Qed.

Lemma kword_suffix_cycle' k n u :
  S k <= n ->
  length u <= A k (n-S k) ->
  Suffix u (kword k n) -> Suffix u (kword k (n-S k)).
Proof.
 intros Hn Hu Su.
 replace n with (S (n-1)) in Su by lia.
 rewrite kword_alt in Su by lia.
 replace (n-1-k) with (n-S k) in Su by lia.
 apply Suffix_app_inv in Su.
 destruct Su as [Su|(u' & E & SU)]; trivial.
 rewrite E, app_length, kword_len in Hu.
 assert (Hu' : length u' = 0) by lia.
 rewrite length_zero_iff_nil in Hu'. subst u'. subst u. now exists [].
Qed.

Lemma kword_suffix_pcycle' k n p u :
  p*S k <= n ->
  length u <= A k (n-p*S k) ->
  Suffix u (kword k n) -> Suffix u (kword k (n-p*S k)).
Proof.
 intros Hn Hu SU. revert Hn Hu.
 induction p.
 - intros _ _. simpl. now replace (n-0) with n by lia.
 - intros Hn Hu.
   replace (n - _) with ((n-p*S k)-S k) in * by lia.
   apply kword_suffix_cycle'. lia. trivial. apply IHp. lia.
   etransitivity; [apply Hu| ]. apply A_mono. lia.
Qed.



(* TODO move *)
Lemma last_cons {A} (a:A) l d : l<>[] -> last (a::l) d = last l d.
Proof.
 now destruct l.
Qed.

Definition lastn {A} n (l:list A) := skipn (length l - n) l.

Lemma lastn_length_le {A} n (l:list A) :
  n <= length l -> length (lastn n l) = n.
Proof.
 intros H. unfold lastn. rewrite skipn_length. lia.
Qed.

Lemma last_app {A} u v (d:A) : v<>[] -> last (u++v) d = last v d.
Proof.
 intros Hv.
 assert (Hv' : length v <> 0) by now destruct v.
 rewrite !last_nth, app_length, app_nth2 by lia. f_equal; lia.
Qed.

Lemma last_seq a n d : last (seq a (S n)) d = a+n.
Proof.
 rewrite seq_S. apply last_last.
Qed.
(* END move *)

Lemma skipn_Suffix n u : Suffix (skipn n u) u.
Proof.
 unfold Suffix. exists (firstn n u). unfold lastn. apply firstn_skipn.
Qed.

Lemma lastn_Suffix n u : Suffix (lastn n u) u.
Proof.
 apply skipn_Suffix.
Qed.

Lemma Prefix_equiv u v : Prefix u v <-> u = firstn (length u) v.
Proof.
 split.
 - intros (u' & <-). rewrite firstn_app.
   replace (_-_) with 0 by lia.
   now rewrite firstn_O, firstn_all, app_nil_r.
 - intros ->. apply firstn_Prefix.
Qed.

Lemma Suffix_equiv u v : Suffix u v <-> u = lastn (length u) v.
Proof.
 split.
 - intros (u' & <-). unfold lastn. rewrite app_length.
   replace (_-_) with (length u') by lia.
   rewrite skipn_app.
   replace (_-_) with 0 by lia.
   now rewrite skipn_O, skipn_all.
 - intros ->. apply lastn_Suffix.
Qed.

(* When n varies, the last letters of the successive [kword k n]
   is k 0 1 ... k 0 *)

Lemma kword_last k n : last (kword k n) 0 = (n+k) mod (S k).
Proof.
 induction n as [n IH] using lt_wf_ind.
 destruct (Nat.le_gt_cases n k).
 - rewrite kword_low by lia.
   destruct n.
   + rewrite Nat.mod_small; simpl; lia.
   + replace (S n + k) with (n + 1 * S k) by lia.
     rewrite Nat.mod_add, Nat.mod_small by lia.
     now rewrite last_cons, last_seq.
 - destruct n as [|n]; try lia.
   replace (S n + k) with (n + 1 * S k) by lia.
   rewrite Nat.mod_add by lia.
   rewrite kword_alt by lia. rewrite last_app.
   2:{ rewrite <- length_zero_iff_nil, kword_len.
       generalize (A_nz k (n - k)). lia. }
   destruct (Nat.eq_dec k n) as [->|NE].
   + now rewrite Nat.sub_diag, Nat.mod_small by lia.
   + replace (n-k) with (S (n-S k)) by lia.
     rewrite IH by lia. f_equal. lia.
Qed.

(** Hence any group of (k+1) successive suffixes is without duplicate *)

Lemma mod_diff a a' b :
  b <> 0 -> a <= a' -> a mod b = a' mod b <-> (a'-a) mod b = 0.
Proof.
 intros Hb Ha.
 split.
 - rewrite (Nat.div_mod_eq a b) at 2.
   rewrite (Nat.div_mod_eq a' b) at 2.
   intros ->.
   replace (_-_) with (b*(a'/b) - b*(a/b)) by lia.
   rewrite <- Nat.mul_sub_distr_l, Nat.mul_comm.
   now rewrite Nat.mod_mul.
 - assert (E := Nat.div_mod_eq (a'-a) b).
   intros E'.
   replace a' with (a + b*((a'-a)/b)) by lia. rewrite Nat.mul_comm.
   rewrite Nat.mod_add; trivial.
Qed.

Lemma kword_suffix_cycle_inv0 k u n m :
  u<>[] -> Suffix u (kword k n) -> Suffix u (kword k m) ->
  n mod (S k) = m mod (S k).
Proof.
 intros Hu. revert n m.
 (* wlog *)
 assert (forall n m, n <= m ->
         Suffix u (kword k n) -> Suffix u (kword k m) ->
         n mod (S k) = m mod (S k)).
 { intros n m LE (v,Hn) (w,Hm).
   rewrite mod_diff; try lia.
   replace (m-n) with ((m+k)-(n+k)) by lia.
   rewrite <- mod_diff; try lia.
   rewrite <- !kword_last, <- Hn, <- Hm.
   now rewrite !last_app. }
 intros n m; destruct (Nat.le_gt_cases n m); intros; auto.
 symmetry; apply H; auto. lia.
Qed.

Definition allsuffixesAt k p n0 :=
  map (fun n => lastn p (kword k n)) (seq n0 (S k)).

Definition allsuffixes k p := allsuffixesAt k p (invA_up k p).

Lemma allsuffixesAt_length k p n0 :
  length (allsuffixesAt k p n0) = S k.
Proof.
 unfold allsuffixesAt. now rewrite map_length, seq_length.
Qed.

Definition SuffixWords u (f : nat -> word) := exists n, Suffix u (f n).

Lemma allsuffixesAt_spec k p n0 :
  p <= A k n0 ->
  forall u, In u (allsuffixesAt k p n0) <->
            length u = p /\ SuffixWords u (kword k).
Proof.
 intros Hn0 u. unfold allsuffixesAt. rewrite in_map_iff. split.
 - intros (n & <- & IN).
   rewrite in_seq in IN. split.
   + rewrite lastn_length_le; auto. rewrite kword_len.
     transitivity (A k n0); trivial. now apply A_mono.
   + exists n. apply lastn_Suffix.
 - intros (Hu,(n & SU)).
   setoid_rewrite in_seq.
   destruct (Nat.le_gt_cases n0 n).
   + assert (NZ : S k <> 0) by lia.
     assert (E := Nat.div_mod (n-n0) (S k) NZ).
     set (r := (n-n0) mod S k) in *.
     set (q := (n-n0) / S k) in *.
     rewrite Nat.mul_comm in E.
     assert (E' : n0+r = n-q*S k) by lia.
     exists (n0+r). split.
     2:{ split. lia. generalize (Nat.mod_upper_bound (n-n0) (S k)). lia. }
     apply (kword_suffix_pcycle' k n q u) in SU; try lia.
     * rewrite <- Hu. symmetry. apply Suffix_equiv. now rewrite E'.
     * rewrite <- E', Hu.
       etransitivity; [apply Hn0| ]. apply A_mono; lia.
   + assert (NZ : S k <> 0) by lia.
     assert (E := Nat.div_mod (n0+k-n) (S k) NZ).
     set (r := (n0+k-n) mod S k) in *.
     set (q := (n0+k-n) / S k) in *.
     assert (E' : n0+k-r = n+q*S k) by lia.
     exists (n0+k-r). split.
     2:{ generalize (Nat.mod_upper_bound (n0+k-n) (S k)). fold r. lia. }
     apply (kword_suffix_pcycle k n q u) in SU.
     rewrite <- Hu. symmetry. apply Suffix_equiv. now rewrite E'.
Qed.

Lemma last_lastn {A} u n (d:A) : n <> 0 -> last (lastn n u) d = last u d.
Proof.
 intros Hn.
 destruct u. trivial.
 unfold lastn.
 rewrite <- (firstn_skipn (length (a::u) - n) (a::u)) at 3.
 symmetry. apply last_app. rewrite <- length_zero_iff_nil, skipn_length.
 simpl length. lia.
Qed.

Lemma allsuffixesAt_nodup k p n0 :
  p<>0 -> NoDup (allsuffixesAt k p n0).
Proof.
  intros Hp.
  unfold allsuffixesAt. set (f := fun n => _).
  apply NoDup_nth with (d:=f 0).
  intros i j. rewrite map_length, seq_length. intros Hi Hj.
  rewrite !map_nth, !seq_nth by lia.
  unfold f; clear f.
  intros E.
  assert (E' : last (kword k (n0+i)) 0 = last (kword k (n0+j)) 0).
  { rewrite <- last_lastn with (n:=p) by trivial.
    rewrite <- (last_lastn (kword k (n0+j)) p) by trivial.
    now f_equal. }
  rewrite !kword_last in E'.
  destruct (Nat.le_gt_cases i j).
  - apply mod_diff in E'; try lia. replace (_-_) with (j-i) in E' by lia.
    rewrite Nat.mod_small in E'; lia.
  - symmetry in E'. apply mod_diff in E'; try lia.
    replace (_-_) with (i-j) in E' by lia.
    rewrite Nat.mod_small in E'; lia.
Qed.

Lemma seq_nshift len start n :
  map (Nat.add n) (seq start len) = seq (n+start) len.
Proof.
 revert start.
 induction n; simpl; intros.
 - now rewrite map_id.
 - now rewrite <- seq_shift, <- IHn, map_map.
Qed.

Lemma allsuffixesAt_permut k p n0 n0' :
  p <= A k n0 -> p <= A k n0' ->
  Permutation (allsuffixesAt k p n0) (allsuffixesAt k p n0').
Proof.
 intros H H'.
 destruct (Nat.eq_dec p 0) as [->|Hp].
 - unfold allsuffixesAt. apply eq_Permutation.
   rewrite <- (Nat.add_0_r n0), <- (Nat.add_0_r n0').
   rewrite <- !(seq_nshift (S k) 0), !map_map.
   apply map_ext. intros a. unfold lastn.
   now rewrite !Nat.sub_0_r, !skipn_all.
 - apply NoDup_Permutation; auto using allsuffixesAt_nodup.
   intros u. rewrite !allsuffixesAt_spec by trivial. reflexivity.
Qed.

Lemma allsuffixes_length k p : length (allsuffixes k p) = S k.
Proof.
 apply allsuffixesAt_length.
Qed.

Lemma allsuffixes_spec k p :
  forall u, In u (allsuffixes k p) <->
            length u = p /\ SuffixWords u (kword k).
Proof.
 apply allsuffixesAt_spec, invA_up_spec.
Qed.

Lemma allsuffixes_nodup k p :
  p<>0 -> NoDup (allsuffixes k p).
Proof.
  apply allsuffixesAt_nodup.
Qed.


(** Complexity of infinite words : for each value of p,
    number of sub-words of length p *)

Definition subseq q n (f:sequence) := map f (seq q n).

Definition SubSeq u (f:sequence) := exists q, u = subseq q (length u) f.

Definition SubpSeq p u (f:sequence) := length u = p /\ SubSeq u f.

Definition AllSubp p l f := NoDup l /\ (forall w, In w l <-> SubpSeq p w f).

Definition Complexity f p n := exists l, AllSubp p l f /\ length l = n.

Lemma app_inv {A} (u u' v v':list A) :
 length u = length v -> u++u' = v++v' -> u=v /\ u'=v'.
Proof.
 revert v. induction u; destruct v; simpl; try easy.
 intros [= E] [= <- E']. apply IHu in E'; trivial. intuition congruence.
Qed.

Lemma SubSeq_alt0 u f : SubSeq u f <-> exists v, Suffix u v /\ PrefixSeq v f.
Proof.
 split.
 - intros (q, E). remember (length u) as n.
   exists (map f (seq 0 (q+n))).
   split.
   + exists (map f (seq 0 q)). subst u. unfold subseq.
     rewrite <- map_app. f_equal. symmetry. apply seq_app.
   + unfold PrefixSeq. now rewrite map_length, seq_length.
 - intros (v & (u' & <-) & PR). exists (length u').
   red in PR. unfold take in PR. rewrite app_length in PR.
   rewrite seq_app, map_app in PR.
   apply app_inv in PR. apply PR. now rewrite map_length, seq_length.
Qed.

Lemma PrefixSeq_app_r u v f : PrefixSeq (u++v) f -> PrefixSeq u f.
Proof.
 unfold PrefixSeq, take. rewrite app_length, seq_app, map_app. intros E.
 apply app_inv in E. apply E. now rewrite map_length, seq_length.
Qed.

Lemma Prefix_PrefixSeq u v f : Prefix u v -> PrefixSeq v f -> PrefixSeq u f.
Proof.
 intros (u' & <-). apply PrefixSeq_app_r.
Qed.

Lemma SubSeq_alt u f : SubSeq u f <-> exists v, Sub u v /\ PrefixSeq v f.
Proof.
 rewrite SubSeq_alt0.
 split.
 - intros (v & SU & PR). exists v; auto using Suffix_Sub.
 - intros (v & (u1 & u2 & <-) & PR). exists (u1++u). split.
   now exists u1. eapply Prefix_PrefixSeq; eauto.
   exists u2; now rewrite app_assoc.
Qed.

Lemma kword_prefixseq k n : PrefixSeq (kword k n) (kseq k).
Proof.
 apply PrefixSeq_napply. apply ksubst_noerase. apply ksubst_prolong.
 reflexivity.
Qed.

Lemma kword_le_prefix k n m : n <= m -> Prefix (kword k n) (kword k m).
Proof.
 induction 1. apply Prefix_id.
 eapply Prefix_trans; eauto.
 destruct (Nat.le_gt_cases m k).
 - rewrite !kword_low by lia.
   exists [m]. now rewrite seq_S.
 - rewrite kword_alt by lia. now exists (kword k (m-k)).
Qed.

Lemma kword_Suffix_Prefix_Sub k u1 u2 n m :
  Suffix u1 (kword k n) -> Prefix u2 (kword k m) ->
  exists q, Sub (u1++u2) (kword k q).
Proof.
 intros SU PR.
 destruct (Nat.le_gt_cases m n).
 - exists (S (n + S k)). rewrite kword_alt by lia.
   assert (HSn : Prefix u2 (kword k (S n))).
   { eapply Prefix_trans; eauto. apply kword_le_prefix. lia. }
   apply kword_suffix_cycle in SU.
   destruct SU as (u1' & E1).
   destruct HSn as (u2' & E2).
   exists u1', u2'. rewrite <- app_assoc, E2, app_assoc, E1.
   f_equal. f_equal. lia.
 - set (m' := n + S ((m-n)/S k)*S k).
   assert (Hm' : m < m').
   { assert (Hk : S k <> 0) by lia.
     assert (E := Nat.div_mod (m-n) (S k) Hk).
     generalize (Nat.mod_upper_bound (m-n) (S k)). lia. }
   apply kword_suffix_pcycle with (p := S ((m-n)/S k)) in SU.
   fold m' in SU.
   assert (HSm' : Prefix u2 (kword k (S m'))).
   { eapply Prefix_trans; eauto. apply kword_le_prefix. lia. }
   exists (S (m' + S k)).
   rewrite kword_alt by lia.
   apply kword_suffix_cycle in SU.
   destruct SU as (u1' & E1).
   destruct HSm' as (u2' & E2).
   exists u1', u2'. rewrite <- app_assoc, E2, app_assoc, E1.
   f_equal. f_equal. lia.
Qed.

Lemma Sub_Prefix_Sub u v w : Sub u v -> Prefix v w -> Sub u w.
Proof.
 intros (u1 & u2 & <-) (v' & <-). exists u1, (u2++v').
 now rewrite !app_assoc.
Qed.

(* Some decidability functions *)

Open Scope lazy_bool_scope.

Fixpoint list_eqb {A} (eqb:A->A->bool) l l' :=
  match l, l' with
  | [], [] => true
  | x::l, x'::l' => (eqb x x') &&& (list_eqb eqb l l')
  | _, _ => false
  end.

Definition reflectEq {A} (eqb:A->A->bool) :=
  forall a a', reflect (a=a') (eqb a a').

Lemma list_eqb_spec {A} (eqb:A->A->bool) :
 reflectEq eqb -> reflectEq (list_eqb eqb).
Proof.
 intros R. red.
 induction a as [|a l IH]; destruct a' as [|a' l']; simpl;
  try case R; try case IH; constructor; congruence.
Qed.

Definition listnat_eqb := list_eqb Nat.eqb.

Definition listnat_eqb_spec := list_eqb_spec Nat.eqb Nat.eqb_spec.

Definition prefixb u v := listnat_eqb u (firstn (length u) v).
Definition suffixb u v := listnat_eqb u (lastn (length u) v).

Lemma prefixb_spec u v : reflect (Prefix u v) (prefixb u v).
Proof.
 unfold prefixb.
 case listnat_eqb_spec; constructor; now rewrite Prefix_equiv.
Qed.

Lemma suffixb_spec u v : reflect (Suffix u v) (suffixb u v).
Proof.
 unfold suffixb.
 case listnat_eqb_spec; constructor; now rewrite Suffix_equiv.
Qed.

Definition sub {A} (l:list A) start len := firstn len (skipn start l).

Lemma sub_alt {A} (l:list A) start len :
 sub l start len = skipn start (firstn (start+len) l).
Proof.
 unfold sub. revert start.
 induction l; destruct start; simpl; auto. now rewrite firstn_nil.
Qed.

Definition subb u v :=
 let len := length u in
 existsb (fun i => listnat_eqb u (sub v i len))
         (seq 0 (S (length v - len))).

Lemma Sub_carac u v : Sub u v <-> exists w, Suffix u w /\ Prefix w v.
Proof.
 split.
 - intros (u1 & u2 & <-). exists (u1++u); split.
   + now exists u1.
   + exists u2. now rewrite app_assoc.
 - intros (w & (u1 & <-) & (u2 & <-)). exists u1, u2.
   now rewrite app_assoc.
Qed.

Lemma Sub_equiv u v :
  Sub u v <->
  exists i, i <= length v - length u /\ u = sub v i (length u).
Proof.
 rewrite Sub_carac. split.
 - intros (w & SU & PR). exists (length w - length u).
   assert (length u <= length w) by now apply Suffix_len.
   assert (length w <= length v) by now apply Prefix_len.
   split. lia. rewrite sub_alt.
   apply Suffix_equiv in SU.
   apply Prefix_equiv in PR. replace (_+_) with (length w) by lia.
   rewrite <- PR. exact SU.
 - intros (i & Hi & E). rewrite sub_alt in E.
   set (w := firstn (i+length u) v) in *.
   exists w; split; [|apply firstn_Prefix].
   rewrite E. apply skipn_Suffix.
Qed.

Lemma subb_spec u v : reflect (Sub u v) (subb u v).
Proof.
 destruct (subb u v) eqn:E; unfold subb in *; constructor.
 - apply existsb_exists in E. destruct E as (i & Hi & E).
   rewrite Sub_equiv. exists i. split.
   + rewrite in_seq in Hi. destruct Hi. simpl in *.
     unfold letter in *; lia.
   + revert E. now case listnat_eqb_spec.
 - rewrite Sub_equiv. intros (i & Hi & E').
   contradict E. rewrite not_false_iff_true, existsb_exists.
   exists i. rewrite in_seq. unfold letter in *; split; try lia.
   now case listnat_eqb_spec.
Qed.

Lemma SubSeq_kseq_Sub_kword k u :
 SubSeq u (kseq k) <-> exists n, Sub u (kword k n).
Proof.
 rewrite SubSeq_alt.
 split.
 - intros (v & SU & PR).
   set (n := invA_up k (length v)).
   exists n.
   eapply Sub_Prefix_Sub; eauto.
   apply PrefixSeq_incl with (kseq k); trivial.
   + rewrite kword_len; apply invA_up_spec.
   + apply kword_prefixseq.
 - intros (n & SU). exists (kword k n); split; trivial.
   apply kword_prefixseq.
Qed.

Lemma Sub_kword_minimal k u n :
 Sub u (kword k n) ->
 exists n0, Sub u (kword k n0) /\ forall q, q<n0 -> ~Sub u (kword k q).
Proof.
 induction n; intros SU.
 - exists 0. split; trivial. inversion 1.
 - destruct (subb_spec u (kword k n)) as [SU'|NS].
   + apply (IHn SU').
   + exists (S n). split; trivial. intros q Hq SU'. apply NS.
     eapply Sub_Prefix_Sub; eauto. apply kword_le_prefix; lia.
Qed.

Lemma SubSeq_kseq_carac k u :
  SubSeq u (kseq k) <->
  Sub u (kword k k) \/
  exists u1 u2, u1<>[] /\ u2<>[] /\ u=u1++u2 /\
     SuffixWords u1 (kword k) /\ PrefixSeq u2 (kseq k).
Proof.
 split.
 - rewrite SubSeq_kseq_Sub_kword. intros (n & SU).
   apply Sub_kword_minimal in SU. clear n.
   destruct SU as (n & SU & NS).
   destruct (Nat.le_gt_cases n k).
   + left. eapply Sub_Prefix_Sub; eauto. apply kword_le_prefix; lia.
   + right. destruct n as [|n]; try lia.
     rewrite kword_alt in SU by lia.
     apply Sub_app_inv in SU.
     destruct SU as [SU|[SU|(u1 & u2 & E & SU & PR)]].
     * exfalso. apply (NS n); auto.
     * exfalso. apply (NS (n-k)); auto; lia.
     * exists u1, u2; repeat split; trivial.
       { intros ->. simpl in E. subst u2. apply Prefix_Sub in PR.
         apply (NS (n-k)); auto; lia. }
       { intros ->. simpl in E. rewrite app_nil_r in E.
         subst u1. apply Suffix_Sub in SU. apply (NS n); auto. }
       { now exists n. }
       { eapply Prefix_PrefixSeq; eauto. apply kword_prefixseq. }
 - rewrite SubSeq_alt.
   intros [SU|(u1 & u2 & Hu1 & Hu2 & E & SU & PR)].
   + exists (kword k k); split; trivial.
     apply PrefixSeq_napply; try easy.
     apply ksubst_noerase. apply ksubst_prolong.
   + subst. destruct SU as (n & SU).
     set (m := invA_up k (length u2)).
     assert (Hm : Prefix u2 (kword k m)).
     { apply PrefixSeq_incl with (kseq k); trivial.
       - rewrite kword_len; apply invA_up_spec.
       - apply kword_prefixseq. }
     destruct (kword_Suffix_Prefix_Sub k u1 u2 n m) as (q & Hq); trivial.
     exists (kword k q); split; auto using kword_prefixseq.
Qed.

Definition allsubs {A} p (u:list A) :=
  map (fun i => sub u i p) (seq 0 (S (length u) - p)).

Lemma allsubs_length {A} p (u:list A) :
  length (allsubs p u) = S (length u) - p.
Proof.
 unfold allsubs. now rewrite map_length, seq_length.
Qed.

Lemma allsubs_ok p u :
  forall w, In w (allsubs p u) <-> length w = p /\ Sub w u.
Proof.
 intros. unfold allsubs. rewrite in_map_iff.
 setoid_rewrite in_seq.
 split.
 - intros (i & <- & Hi).
   rewrite Sub_equiv.
   replace (length (sub u i p)) with p.
   2:{ unfold sub. rewrite firstn_length_le; auto.
       rewrite skipn_length. lia. }
   split; trivial. exists i. split; auto; lia.
 - intros (L & S). assert (L' := Sub_len _ _ S).
   rewrite Sub_equiv in S. destruct S as (i & Hi & E).
   exists i. split. congruence. lia.
Qed.

Lemma skipn_seq a b n : skipn n (seq a b) = seq (n+a) (b-n).
Proof.
 revert a b.
 induction n; intros; simpl.
 - f_equal. lia.
 - destruct b; simpl; auto.
   rewrite IHn. f_equal. lia.
Qed.

Lemma firstn_seq a b n : n <= b -> firstn n (seq a b) = seq a n.
Proof.
 induction 1.
 - rewrite <- (seq_length n a) at 1. apply firstn_all.
 - rewrite seq_S, firstn_app, IHle.
   rewrite seq_length. replace (n-m) with 0 by lia. simpl. apply app_nil_r.
Qed.

Lemma allsubs_kword_nodup k p : p<>0 -> NoDup (allsubs p (kword k k)).
Proof.
 intros Hp.
 unfold allsubs.
 rewrite kword_low by lia. simpl length. rewrite seq_length.
 set (f := fun i => _).
 rewrite NoDup_nth with (d:=f 0).
 rewrite map_length, seq_length. intros i j Hi Hj.
 rewrite !map_nth, !seq_nth; auto. unfold f; clear f. simpl.
 assert (F0 : hd 0 (sub (k::seq 0 k) 0 p) = k).
 { unfold hd, sub. simpl. destruct p; simpl; lia. }
 assert (F : forall x, 0<S x<S (S k)-p ->
             hd 0 (sub (k::seq 0 k) (S x) p) = x).
 { intros x Hx. unfold hd, sub. simpl. rewrite skipn_seq.
   rewrite firstn_seq by lia. destruct p; simpl; lia. }
 intros E.
 assert (E' : hd 0 (sub (k :: seq 0 k) i p) =
              hd 0 (sub (k :: seq 0 k) j p)).
 { unfold letter in E. now rewrite E. }
 clear E.
 destruct i, j; trivial.
 - rewrite F0, (F j) in E'; lia.
 - rewrite (F i), F0 in E'; lia.
 - rewrite (F i), (F j) in E'; lia.
Qed.

Definition add_suffix l (v:word) := map (fun u => u++v) l.

Definition kseq_prefix k n :=
  let p := invA_up k n in
  firstn n (kword k p).

Lemma kseq_prefix_length k n : length (kseq_prefix k n) = n.
Proof.
 unfold kseq_prefix. rewrite firstn_length_le; auto.
 rewrite kword_len. apply invA_up_spec.
Qed.

Lemma kseq_prefix_ok k n : PrefixSeq (kseq_prefix k n) (kseq k).
Proof.
 unfold kseq_prefix. eapply Prefix_PrefixSeq; eauto.
 apply firstn_Prefix. apply kword_prefixseq.
Qed.

(* A first listing of factors, which is complete but may contain
   a few duplicates *)

Definition ksubsdups k p :=
 allsubs p (kword k k) ++
 concat (map (fun p1 =>
                add_suffix (allsuffixes k p1) (kseq_prefix k (p-p1)))
             (seq 1 (p-1))).

Lemma ksubsdups_ok k p u :
  In u (ksubsdups k p) <-> length u = p /\ SubSeq u (kseq k).
Proof.
 unfold ksubsdups. rewrite in_app_iff, allsubs_ok.
 rewrite SubSeq_kseq_carac, in_concat. setoid_rewrite in_map_iff.
 split.
 - intros [(L,S)|(ll & (p1 & <- & IN) & IN')].
   + split; auto.
   + rewrite in_seq in IN. unfold add_suffix in IN'.
     rewrite in_map_iff in IN'. destruct IN' as (u1 & <- & IN').
     rewrite allsuffixes_spec in IN'. destruct IN' as (IN', SU).
     destruct SU as (m & SU).
     set (u2 := kseq_prefix k (p-p1)).
     split.
     * rewrite app_length, IN'. unfold u2.
       rewrite kseq_prefix_length. lia.
     * right. exists u1, u2; repeat split.
       { rewrite <- length_zero_iff_nil, IN'. lia. }
       { rewrite <- length_zero_iff_nil. unfold u2.
         rewrite kseq_prefix_length. lia. }
       { now exists m. }
       { unfold u2. apply kseq_prefix_ok. }
 - intros (L, [S|(u1 & u2 & Hu1 & Hu2 & -> & SU & PR)]).
   + left; auto.
   + right. setoid_rewrite in_seq.
     rewrite app_length in L.
     set (p1 := length u1) in *.
     assert (E : u2 = kseq_prefix k (p-p1)).
     { apply Prefix_antisym;
       apply PrefixSeq_incl with (kseq k); auto using kseq_prefix_ok;
       (rewrite kseq_prefix_length; lia). }
     exists (add_suffix (allsuffixes k p1) u2).
     split.
     * exists p1. split. now rewrite E.
       rewrite <- length_zero_iff_nil in Hu1, Hu2. lia.
     * unfold add_suffix. set (f := fun u => _).
       change (u1 ++ u2) with (f u1). apply in_map. clear f.
       rewrite allsuffixes_spec; auto.
Qed.

(* Avec a on peut dj dire que la complexit est linaire
(* Mais ksubsdups k n contient n-(k+2) doublons en trop *)

(* TODO: ksubsdups optimis pour viter tout calcul rptitif ?
   application  la quasi-additivit ?
   est-ce que a donne -2..2 pour k=2 sans axiomes rels ?
 *)

(* Idee : left_special prserv par subst ? *)


(*
Lemma Complexity_kseq k : forall p, Complexity (kseq k) p (k*p+1).
Proof.
Admitted. (* TODO *)
*)

(* TODO : explicitely enumerate these (k*p+1) sub-words of length p
   and deduce additivity bounds for f in a nicer way than in GenAdd ! *)
