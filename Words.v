Require Import Arith Lia List Bool.
Require Import DeltaList GenFib GenG.
Import ListNotations.

(** * Morphic words

    Some theory of infinite words generated by substitutions.
    Hofstadter functions [f k] can be described by such infinite
    words, or more precisely their derivative
    (fun n => f k (S n) - f k n)
*)

(** letters : here some natural numbers *)

Definition letter := nat.

(** Finite word : list of letters *)

Definition word := list letter.

Definition Prefix (u v:word) := exists w, u++w = v.

Lemma Prefix_nth u v :
  Prefix u v -> forall n a, n < length u -> nth n u a = nth n v a.
Proof.
 intros (w & <-). intros n a LT. rewrite app_nth1; auto.
Qed.

(** Sequence a.k.a Infinite word : function from nat to letter *)

Definition seq := nat -> letter.

Fixpoint take n (f:seq) : word :=
  match n with
  | 0 => []
  | S n => take n f ++ [f n]
  end.

Lemma take_length n f : length (take n f) = n.
Proof.
 induction n; simpl; auto. rewrite app_length; simpl. lia.
Qed.

Lemma take_nth f n m a : m < n -> nth m (take n f) a = f m.
Proof.
 revert m.
 induction n; simpl; intros m H.
 - inversion H.
 - inversion H; subst.
   + rewrite app_nth2; rewrite take_length; auto.
     replace (n-n) with 0 by lia. auto.
   + rewrite app_nth1. apply IHn; auto. now rewrite take_length.
Qed.

Lemma rev_switch {A} (l l' : list A) : rev l = l' -> l = rev l'.
Proof.
 intros. now rewrite <- (rev_involutive l), H.
Qed.

Lemma take_carac n u f :
 length u = n ->
 (forall m a, m<n -> nth m u a = f m) ->
 take n f = u.
Proof.
 revert u f.
 induction n.
 - destruct u; simpl; easy.
 - intros u f Hu H.
   simpl.
   destruct (rev u) as [|a ru] eqn:E.
   + apply rev_switch in E. now subst u.
   + apply rev_switch in E. simpl in E. subst u.
     rewrite app_length in Hu. simpl in Hu.
     f_equal.
     * apply IHn; try lia.
       intros m b Hm.
       specialize (H m b). rewrite app_nth1 in H; auto; lia.
     * f_equal.
       specialize (H n a). rewrite app_nth2 in H; auto; try lia.
       replace (n - length (rev ru)) with 0 in H by lia. simpl in H.
       symmetry. apply H; auto.
Qed.

Definition PrefixSeq u f := u = take (length u) f.

(** Substitution : function form letter to words *)

Definition subst := letter -> word.

Fixpoint apply (s:subst) w :=
  match w with
  | [] => []
  | a::w => s a ++ apply s w
  end.

Fixpoint napply (s:subst) n w :=
  match n with
  | 0 => w
  | S n => napply s n (apply s w)
  end.

Lemma apply_app s u v : apply s (u++v) = apply s u ++ apply s v.
Proof.
 induction u; simpl; auto.
 now rewrite IHu, app_assoc.
Qed.

Lemma napply_app s n u v : napply s n (u++v) = napply s n u ++ napply s n v.
Proof.
 revert u v. induction n; intros; simpl; auto.
 now rewrite apply_app, IHn.
Qed.

Lemma napply_cons s n a u : napply s n (a::u) = napply s n [a] ++ napply s n u.
Proof.
 apply (napply_app s n [a] u).
Qed.

Lemma napply_alt s n u : napply s (S n) u = apply s (napply s n u).
Proof.
 revert u.
 induction n; intros; simpl; auto.
 now rewrite <- IHn.
Qed.

Lemma napply_add s n m u : napply s (n+m) u = napply s n (napply s m u).
Proof.
 induction n.
 - simpl; auto.
 - now rewrite Nat.add_succ_l, !napply_alt, IHn.
Qed.

Definition NoErase (s:subst) := forall a, s a <> [].

Definition Prolong (s:subst) a := exists u, u<>[] /\ s a = a::u.

Lemma noerase_nonnil_apply s u : NoErase s -> u<>[] -> apply s u <> [].
Proof.
 intros NE. destruct u as [|a u]. easy. intros _. simpl.
 specialize (NE a). destruct (s a) as [|b v]; easy.
Qed.

Lemma noerase_nonnil_napply s u n : NoErase s -> u<>[] -> napply s n u <> [].
Proof.
 intros NE. revert u. induction n; simpl; intros; auto.
 apply IHn. apply noerase_nonnil_apply; auto.
Qed.

Lemma noerase_prolong_napply_len s a :
  NoErase s -> Prolong s a -> forall n, n < length (napply s n [a]).
Proof.
 intros NE (u & Hu & PR).
 induction n. simpl; auto.
 simpl. rewrite app_nil_r, PR, napply_cons, app_length.
 assert (length (napply s n u) <> 0).
 { rewrite length_zero_iff_nil. now apply noerase_nonnil_napply. }
 lia.
Qed.

Lemma napply_prefix_S s a n :
 Prolong s a -> Prefix (napply s n [a]) (napply s (S n) [a]).
Proof.
 intros (u & Hu & PR).
 simpl. rewrite app_nil_r, PR. rewrite (napply_cons _ _ _ u).
 now exists (napply s n u).
Qed.

Lemma napply_prefix_mono s a n m : Prolong s a -> n <= m ->
 Prefix (napply s n [a]) (napply s m [a]).
Proof.
 intros PR.
 induction 1.
 - exists []. apply app_nil_r.
 - destruct IHle as (w & E).
   destruct (napply_prefix_S s a m) as (w' & E'); auto.
   exists (w++w'). now rewrite app_assoc, E, E'.
Qed.

(** Any nonerasing prolongeable substitution leads to a unique infinite
    sequence *)

Definition SubstSeq (s:subst) (f:seq) a :=
  forall n, PrefixSeq (napply s n [a]) f.

Definition subst2seq s a :=
 fun n => nth n (napply s n [a]) a.

Lemma subst2seq_indep s a n : NoErase s -> Prolong s a ->
  forall m, n <= m -> subst2seq s a n = nth n (napply s m [a]) a.
Proof.
 intros. apply Prefix_nth. apply napply_prefix_mono; auto.
 apply noerase_prolong_napply_len; auto.
Qed.

Lemma substseq_exists s a :
  NoErase s -> Prolong s a -> SubstSeq s (subst2seq s a) a.
Proof.
 intros NE PR n.
 red. symmetry. apply take_carac; auto.
 intros m b Hm.
 unfold subst2seq.
 rewrite (nth_indep _ b a); auto.
 destruct (Nat.le_gt_cases n m).
 - apply Prefix_nth; auto.
   apply napply_prefix_mono; auto.
 - symmetry.
   apply Prefix_nth; auto.
   apply napply_prefix_mono; auto with arith.
   apply noerase_prolong_napply_len; auto.
Qed.

Lemma substseq_unique s a f f' :
  NoErase s -> Prolong s a -> SubstSeq s f a -> SubstSeq s f' a ->
  (forall n, f n = f' n).
Proof.
 intros NE PR Hf Hf' n.
 specialize (Hf (S n)).
 specialize (Hf' (S n)). unfold PrefixSeq in *.
 set (u := napply s (S n) [a]) in *.
 rewrite <- (take_nth f (length u) n a).
 2:{ transitivity (S n); auto. apply noerase_prolong_napply_len; auto. }
 rewrite <- (take_nth f' (length u) n a); auto.
 2:{ transitivity (S n); auto. apply noerase_prolong_napply_len; auto. }
 now rewrite <- Hf, <- Hf'.
Qed.

(* Auxiliary result *)

Lemma seq_S a b : List.seq a (S b) = List.seq a b ++ [a+b].
Proof.
 revert a.
 induction b; simpl; intros. f_equal; lia.
 rewrite Nat.add_succ_r, <- Nat.add_succ_l. now rewrite <- IHb.
Qed.

(** Specific susbstitution for Hofstadter functions.
    Works on letters 0..k *)

Definition ksubst k n := if n =? k then [k; 0] else [S n].

Definition kword k n := napply (ksubst k) n [k].

Definition kseq k := subst2seq (ksubst k) k.

(* Compute map (kseq 2) (List.seq 0 20). *)
(* [2; 0; 1; 2; 2; 0; 2; 0; 1; 2; 0; 1; 2; 2; 0; 1; 2; 2; 0; 2] *)

(** Initial values *)

Lemma kword_0 k : kword k 0 = [k].
Proof.
 reflexivity.
Qed.

Lemma kword_1 k : kword k 1 = [k;0].
Proof.
 cbn. unfold ksubst. now rewrite Nat.eqb_refl.
Qed.

Lemma ksubst_low0 k n : n <= k -> napply (ksubst k) n [0] = [n].
Proof.
 induction n. auto.
 intros LE.
 rewrite napply_alt. rewrite IHn; try lia. simpl.
 unfold ksubst. case Nat.eqb_spec. lia. intros _. apply app_nil_r.
Qed.

Lemma kword_low k n : n <= S k -> kword k n = k :: List.seq 0 n.
Proof.
 induction n.
 - now rewrite kword_0.
 - intros LE.
   rewrite seq_S.
   cbn. unfold ksubst at 2. rewrite Nat.eqb_refl. simpl.
   rewrite napply_cons.
   rewrite ksubst_low0; auto; try lia.
   change (kword k n ++ [n] = k  :: List.seq 0 n ++ [n]).
   rewrite IHn; try lia. auto.
Qed.

(** Alt equation : *)

Lemma kword_alt k n : k<=n -> kword k (S n) = kword k n ++ kword k (n-k).
Proof.
 induction n.
 - intros. replace k with 0 by lia. simpl; auto.
 - intros LE. apply Nat.lt_eq_cases in LE. destruct LE as [LT|EQ].
   + replace (S n -k) with (S (n-k)) by lia.
     remember (S n) as m eqn:E.
     cbn.
     rewrite app_nil_r.
     unfold ksubst at 2. rewrite Nat.eqb_refl.
     rewrite napply_cons. f_equal.
     replace m with (m-k+k) by lia.
     rewrite napply_add. rewrite ksubst_low0 by lia. simpl.
     replace (m-k) with (S (n-k)) by lia.
     simpl. now rewrite app_nil_r.
   + rewrite <- EQ. replace (k-k) with 0 by lia.
     rewrite kword_0. cbn.
     unfold ksubst at 2. rewrite Nat.eqb_refl, app_nil_r.
     rewrite napply_cons. f_equal. apply ksubst_low0. lia.
Qed.

Lemma kword_len k n : length (kword k n) = A k n.
Proof.
 induction n as [[|n] IH] using lt_wf_ind.
 - now rewrite kword_0.
 - case (Nat.le_gt_cases k n) as [LE|GT].
   + rewrite kword_alt; auto. rewrite app_length, !IH; try lia.
     simpl; auto.
   + rewrite kword_low by auto. simpl.
     rewrite seq_length. rewrite !A_base; lia.
Qed.

(** Link between [kseq] and Zeckendorf decomposition :
    0 iff rank 0,
    1 iff rank 1,
    ...
    k iff rank >= k (or no rank, ie n=0)

    Hence 0 in [kseq] whenever the [f k] function is flat.
*)

Definition bounded_rank k n :=
 match rank k n with
 | None => k
 | Some p => Nat.min p k
 end.

Lemma kseq_bounded_rank k n : kseq k n = bounded_rank k n.
Proof.
 induction n as [n IH] using lt_wf_ind.
 assert (E := decomp_sum k n).
 assert (D := decomp_delta k n).
 set (l := decomp k n) in *.
 destruct (rev l) as [|a rl] eqn:E'; apply rev_switch in E'.
 - rewrite E' in *. simpl in E. rewrite <- E. easy.
 - assert (A k a <= n < A k (S a)).
   { rewrite <- E, E', sumA_rev.
     split.
     + simpl; lia.
     + apply decomp_max. apply Delta_rev. now rewrite <- E'. }
   assert (NE : NoErase (ksubst k)).
   { red. intros c. unfold ksubst. now case Nat.eqb_spec. }
   assert (PR : Prolong (ksubst k) k).
   { red. exists [0]. split. easy.
     unfold ksubst. now rewrite Nat.eqb_refl. }
   assert (SU := substseq_exists _ _ NE PR (S a)).
   unfold PrefixSeq in SU.
   change (napply _ _ _) with (kword k (S a)) in SU.
   change (subst2seq _ _) with (kseq k) in SU.
   rewrite kword_len in SU.
   replace (kseq k n) with (nth n (kword k (S a)) 0).
   2:{ rewrite SU. rewrite take_nth; auto. lia. }
   clear SU.
   destruct (Nat.lt_ge_cases a k) as [LT|LE].
   + rewrite kword_low by lia.
     destruct n as [|n]; try easy.
     change (nth _ _ _) with (nth n (List.seq 0 (S a)) 0).
     rewrite !A_base in H; try lia.
     replace n with a by lia.
     rewrite seq_nth by lia. simpl.
     unfold bounded_rank, rank.
     replace (S a) with (sumA k [a]).
     2:{ rewrite <- (@A_base k a); simpl; lia. }
     rewrite decomp_sum'; try constructor. rewrite Nat.min_l; auto; try lia.
   + rewrite kword_alt by auto.
     rewrite app_nth2; rewrite kword_len; try lia.
     set (m := n - A k a) in *.
     assert (Hm : m < n) by (generalize (@A_nz k a); lia).
     specialize (IH m Hm).
     assert (SU' := substseq_exists _ _ NE PR (a-k)).
     unfold PrefixSeq in SU'.
     change (napply _ _ _) with (kword k (a-k)) in SU'.
     change (subst2seq _ _) with (kseq k) in SU'.
     rewrite kword_len in SU'.
     rewrite SU', take_nth.
     2:{ unfold m. simpl in H. lia. }
     rewrite IH. clear SU' NE PR.
     unfold m.
     unfold bounded_rank, rank. fold l. rewrite E'.
     simpl rev.
     replace (n-A k a) with (sumA k (rev rl)).
     2:{ rewrite <-E, E'. simpl. rewrite sumA_app. simpl. lia. }
     rewrite decomp_sum'.
     2:{ rewrite E' in D. simpl in D. apply Delta_app_iff in D. intuition. }
     destruct (rev rl) eqn:E''; simpl; auto. rewrite Nat.min_r; auto.
Qed.

(** Another possible susbstitution for Hofstadter functions,
    giving [min (rank n) (S k)] instead of [min (rank n) k].
    Hence it works on 0..(S k) instead of 0..k *)

Definition ksubstbis k n := if n <? k then [S n] else [S k; 0].

Definition kwordbis k n := napply (ksubstbis k) n [S k].

Definition kseqbis k := subst2seq (ksubstbis k) (S k).

(* Compute map (kseqbis 2) (List.seq 0 20). *)
(* [3; 0; 1; 2; 3; 0; 3; 0; 1; 3; 0; 1; 2; 3; 0; 1; 2; 3; 0; 3] *)

(** Initial values *)

Lemma kwordbis_0 k : kwordbis k 0 = [S k].
Proof.
 reflexivity.
Qed.

Lemma kwordbis_1 k : kwordbis k 1 = [S k; 0].
Proof.
 cbn. unfold ksubstbis.
 case Nat.ltb_spec; auto. lia.
Qed.

Lemma ksubstbis_low0 k n : n <= k -> napply (ksubstbis k) n [0] = [n].
Proof.
 induction n. auto.
 intros LE.
 rewrite napply_alt. rewrite IHn; try lia. simpl.
 unfold ksubstbis. case Nat.ltb_spec; auto. lia.
Qed.

Lemma ksubstbis_low0' k : napply (ksubstbis k) (S k) [0] = [S k; 0].
Proof.
 change (S k) with (1+k) at 1. rewrite napply_add.
 rewrite ksubstbis_low0 by lia. simpl.
 unfold ksubstbis. case Nat.ltb_spec; auto. lia.
Qed.

Lemma kwordbis_low k n : n <= S k -> kwordbis k n = S k :: List.seq 0 n.
Proof.
 induction n.
 - now rewrite kwordbis_0.
 - intros LE.
   rewrite seq_S.
   cbn. unfold ksubstbis at 2. case Nat.ltb_spec; try lia. intros _.
   simpl. rewrite napply_cons.
   rewrite ksubstbis_low0; auto; try lia.
   change (kwordbis k n ++ [n] = S k :: List.seq 0 n ++ [n]).
   rewrite IHn; try lia. auto.
Qed.

(** Alt equation : *)

Lemma kwordbis_alt k n :
  k<n -> kwordbis k (S n) = kwordbis k n ++ kwordbis k (n-k).
Proof.
 induction n.
 - inversion 1.
 - rewrite Nat.lt_succ_r, Nat.lt_eq_cases.
   intros [LT| <-].
   + replace (S n -k) with (S (n-k)) by lia.
     remember (S n) as m eqn:E.
     cbn.
     rewrite app_nil_r.
     unfold ksubstbis at 2. case Nat.ltb_spec; try lia. intros _.
     rewrite napply_cons. f_equal.
     replace m with (m-k+k) by lia.
     rewrite napply_add. rewrite ksubstbis_low0 by lia.
     replace (m-k) with (S (n-k)) by lia.
     simpl. f_equal. unfold ksubstbis.
     do 2 (case Nat.ltb_spec; try lia). auto.
   + clear IHn.
     replace (S k-k) with 1 by lia. rewrite kwordbis_1.
     remember (S k) as m eqn:E.
     unfold kwordbis at 1. simpl. unfold ksubstbis at 2.
     case Nat.ltb_spec; try lia. intros _. simpl.
     rewrite napply_cons. f_equal. subst m. apply ksubstbis_low0'.
Qed.

Lemma kwordbis_len k n : length (kwordbis k n) = A k n.
Proof.
 induction n as [[|n] IH] using lt_wf_ind.
 - now rewrite kwordbis_0.
 - case (Nat.lt_ge_cases k n) as [LT|GE].
   + rewrite kwordbis_alt; auto. rewrite app_length, !IH; try lia.
     simpl; auto.
   + rewrite kwordbis_low by lia. simpl.
     rewrite seq_length. rewrite !A_base; lia.
Qed.

(** Link between [kseqbis] and Zeckendorf decomposition :
    0 iff rank 0,
    1 iff rank 1,
    ...
    (S k) iff rank > k (or no rank, ie n=0)

    Hence 0 in [kseqbis] whenever the [f k] function is flat.
*)

Definition bounded_rankbis k n :=
 match rank k n with
 | None => S k
 | Some p => Nat.min p (S k)
 end.

Lemma kseqbis_bounded_rank k n : kseqbis k n = bounded_rankbis k n.
Proof.
 induction n as [n IH] using lt_wf_ind.
 assert (E := decomp_sum k n).
 assert (D := decomp_delta k n).
 set (l := decomp k n) in *.
 destruct (rev l) as [|a rl] eqn:E'; apply rev_switch in E'.
 - rewrite E' in *. simpl in E. rewrite <- E. easy.
 - assert (A k a <= n < A k (S a)).
   { rewrite <- E, E', sumA_rev.
     split.
     + simpl; lia.
     + apply decomp_max. apply Delta_rev. now rewrite <- E'. }
   assert (NE : NoErase (ksubstbis k)).
   { red. intros c. unfold ksubstbis. now case Nat.ltb_spec. }
   assert (PR : Prolong (ksubstbis k) (S k)).
   { red. exists [0]. split. easy.
     unfold ksubstbis. case Nat.ltb_spec; auto; try lia. }
   assert (SU := substseq_exists _ _ NE PR (S a)).
   unfold PrefixSeq in SU.
   change (napply _ _ _) with (kwordbis k (S a)) in SU.
   change (subst2seq _ _) with (kseqbis k) in SU.
   rewrite kwordbis_len in SU.
   replace (kseqbis k n) with (nth n (kwordbis k (S a)) 0).
   2:{ rewrite SU. rewrite take_nth; auto. lia. }
   clear SU.
   destruct (Nat.le_gt_cases a k) as [LE|LT].
   + rewrite kwordbis_low by lia.
     destruct n as [|n]; try easy.
     change (nth _ _ _) with (nth n (List.seq 0 (S a)) 0).
     rewrite !A_base in H; try lia.
     replace n with a by lia.
     rewrite seq_nth by lia. simpl.
     unfold bounded_rankbis, rank.
     replace (S a) with (sumA k [a]).
     2:{ rewrite <- (@A_base k a); simpl; lia. }
     rewrite decomp_sum'; try constructor. rewrite Nat.min_l; auto; try lia.
   + rewrite kwordbis_alt by auto.
     rewrite app_nth2; rewrite kwordbis_len; try lia.
     set (m := n - A k a) in *.
     assert (Hm : m < n) by (generalize (@A_nz k a); lia).
     specialize (IH m Hm).
     assert (SU' := substseq_exists _ _ NE PR (a-k)).
     unfold PrefixSeq in SU'.
     change (napply _ _ _) with (kwordbis k (a-k)) in SU'.
     change (subst2seq _ _) with (kseqbis k) in SU'.
     rewrite kwordbis_len in SU'.
     rewrite SU', take_nth.
     2:{ unfold m. simpl in H. lia. }
     rewrite IH. clear SU' NE PR.
     unfold m.
     unfold bounded_rankbis, rank. fold l. rewrite E'.
     simpl rev.
     replace (n-A k a) with (sumA k (rev rl)).
     2:{ rewrite <-E, E'. simpl. rewrite sumA_app. simpl. lia. }
     rewrite decomp_sum'.
     2:{ rewrite E' in D. simpl in D. apply Delta_app_iff in D. intuition. }
     destruct (rev rl) eqn:E''; simpl; auto. rewrite Nat.min_r; auto.
Qed.

Lemma kseqbis_kseq k n : kseq k n = Nat.min k (kseqbis k n).
Proof.
 rewrite kseq_bounded_rank, kseqbis_bounded_rank.
 unfold bounded_rank, bounded_rankbis.
 destruct rank.
 - rewrite (Nat.min_comm _ (S k)), Nat.min_assoc.
   rewrite (Nat.min_l k) by auto. apply Nat.min_comm.
 - rewrite Nat.min_l; auto.
Qed.

(** Counting letter 0 in [kseq k] leads back to the [f k] fonction.
    [count f a n] is the number of letter [a] in [(f 0) .. (f (pred n))]. *)

Fixpoint count f a n :=
 match n with
 | 0 => 0
 | S n => count f a n + if f n =? a then 1 else 0
 end.

Lemma f_count_0 k n : k<>0 -> count (kseq k) 0 n + f k n = n.
Proof.
 induction n.
 - easy.
 - simpl. intros Hk.
   rewrite kseq_bounded_rank.
   unfold bounded_rank.
   destruct (f_step k n) as [E|E].
   + rewrite E. rewrite flat_rank_0 in E. rewrite E. simpl. lia.
   + rewrite E. rewrite step_rank_nz in E.
     destruct (rank k n) as [[|r]|]; simpl; try easy;
       destruct k; simpl; auto; try lia.
Qed.

(** Similarly, counting all letters above [p] leads to [(f k)^^p],
    the p-iterate of [f k]. *)

Fixpoint count_above f a n :=
 match n with
 | 0 => 0
 | S n => count_above f a n + if a <=? f n then 1 else 0
 end.

Lemma fs_count_above k p n :
  p <= k -> Nat.iter p (f k) n = count_above (kseq k) p n.
Proof.
 intros Hp.
 induction n.
 - simpl. apply fs_k_0.
 - simpl. rewrite kseq_bounded_rank.
   unfold bounded_rank.
   destruct (fs_step k p n) as [E|E].
   + rewrite E. rewrite fs_flat_low_rank in E by lia.
     destruct (rank k n); try easy.
     red in E. case Nat.leb_spec; lia.
   + rewrite E. rewrite fs_nonflat_high_rank in E by lia.
     destruct (rank k n); unfold olt in E; case Nat.leb_spec; lia.
Qed.

(* Particular case : p=k *)

Lemma count_above_kseq_k k n :
  count_above (kseq k) k n = count (kseq k) k n.
Proof.
 induction n; simpl; auto.
 rewrite kseq_bounded_rank. unfold bounded_rank.
 destruct (rank k n); case Nat.leb_spec; case Nat.eqb_spec; lia.
Qed.

Lemma fs_count_k k n : Nat.iter k (f k) n = count (kseq k) k n.
Proof.
 rewrite fs_count_above by lia.
 apply count_above_kseq_k.
Qed.
