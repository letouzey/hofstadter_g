Require Import DeltaList FunG GenFib GenG.
Import ListNotations.

(** * Morphic words

    Some theory of infinite words generated by substitutions.
    Hofstadter functions [f k] can be described by such infinite
    words, or more precisely their derivative
    (fun n => f k (S n) - f k n)
*)

(** letters : here some natural numbers *)

Definition letter := nat.

(** Finite word : list of letters *)

Definition word := list letter.

Definition Prefix (u v:word) := exists w, u++w = v.

Lemma Prefix_id w : Prefix w w.
Proof.
 exists []. apply app_nil_r.
Qed.

Lemma Prefix_len u v : Prefix u v -> length u <= length v.
Proof.
 intros (w,<-). rewrite app_length. lia.
Qed.

Lemma Prefix_nil u : Prefix u [] -> u = [].
Proof.
 intros Pr. apply Prefix_len in Pr. simpl in Pr. now destruct u.
Qed.

Lemma Prefix_cons a u v : Prefix u v -> Prefix (a::u) (a::v).
Proof.
 intros (w,<-). now exists w.
Qed.

Lemma Prefix_nth u v :
  Prefix u v <-> forall n a, n < length u -> nth n u a = nth n v a.
Proof.
 split.
 - intros (w & <-). intros n a LT. rewrite app_nth1; auto.
 - revert v. induction u; intros v H.
   + now exists v.
   + destruct v.
     * specialize (H 0 (S a)). simpl in H. lia.
     * assert (P : Prefix u v).
       { apply IHu. intros n b H'. apply (H (S n) b); simpl; auto with arith. }
       destruct P as (w & P).
       exists w. simpl. f_equal; auto.
       apply (H 0 0). simpl. lia.
Qed.

Lemma Prefix_cons_inv a u v :
  Prefix u (a::v) -> u = [] \/ exists u', u = a::u' /\ Prefix u' v.
Proof.
 intros (w,E).
 destruct u as [|a' u'].
 - now left.
 - right. exists u'. injection E as -> E'. split; auto. now exists w.
Qed.

Lemma Prefix_app u v w :
 Prefix u (v++w) -> Prefix u v \/ exists u', u = v++u' /\ Prefix u' w.
Proof.
 revert v w.
 induction u.
 - intros v w _. left. now exists v.
 - intros v w (t,E). simpl in E.
   destruct v.
   + right. exists (a::u). split; auto. now exists t.
   + injection E as <- E.
     destruct (IHu v w) as [IH|(u',IH)]; try now exists t.
     * left. now apply Prefix_cons.
     * right. exists u'. simpl; split. now f_equal. apply IH.
Qed.

Lemma Prefix_seq w a n :
 Prefix w (List.seq a n) -> w = List.seq a (length w).
Proof.
 revert w a.
 induction n as [|n IH]; simpl; intros w a P.
 - apply Prefix_nil in P. now subst w.
 - apply Prefix_cons_inv in P. destruct P as [->|(w' & -> & P)]; trivial.
   simpl. f_equal; auto.
Qed.

(** Sequence a.k.a Infinite word : function from nat to letter *)

Definition seq := nat -> letter.

Fixpoint take n (f:seq) : word :=
  match n with
  | 0 => []
  | S n => take n f ++ [f n]
  end.

Lemma take_length n f : length (take n f) = n.
Proof.
 induction n; simpl; auto. rewrite app_length; simpl. lia.
Qed.

Lemma take_nth f n m a : m < n -> nth m (take n f) a = f m.
Proof.
 revert m.
 induction n; simpl; intros m H.
 - inversion H.
 - inversion H; subst.
   + rewrite app_nth2; rewrite take_length; auto.
     replace (n-n) with 0 by lia. auto.
   + rewrite app_nth1. apply IHn; auto. now rewrite take_length.
Qed.

Lemma rev_switch {A} (l l' : list A) : rev l = l' -> l = rev l'.
Proof.
 intros. now rewrite <- (rev_involutive l), H.
Qed.

Lemma take_carac n u f :
 length u = n ->
 (forall m a, m<n -> nth m u a = f m) ->
 take n f = u.
Proof.
 revert u f.
 induction n.
 - destruct u; simpl; easy.
 - intros u f Hu H.
   simpl.
   destruct (rev u) as [|a ru] eqn:E.
   + apply rev_switch in E. now subst u.
   + apply rev_switch in E. simpl in E. subst u.
     rewrite app_length in Hu. simpl in Hu.
     f_equal.
     * apply IHn; try lia.
       intros m b Hm.
       specialize (H m b). rewrite app_nth1 in H; auto; lia.
     * f_equal.
       specialize (H n a). rewrite app_nth2 in H; auto; try lia.
       replace (n - length (rev ru)) with 0 in H by lia. simpl in H.
       symmetry. apply H; auto.
Qed.

Definition PrefixSeq u f := u = take (length u) f.

(** Substitution : function form letter to words *)

Definition subst := letter -> word.

Fixpoint apply (s:subst) w :=
  match w with
  | [] => []
  | a::w => s a ++ apply s w
  end.

Fixpoint napply (s:subst) n w :=
  match n with
  | 0 => w
  | S n => napply s n (apply s w)
  end.

Lemma apply_app s u v : apply s (u++v) = apply s u ++ apply s v.
Proof.
 induction u; simpl; auto.
 now rewrite IHu, app_assoc.
Qed.

Lemma apply_alt s w : apply s w = concat (map s w).
Proof.
 induction w; simpl; auto. now f_equal.
Qed.

Lemma napply_nil s n : napply s n [] = [].
Proof.
 induction n; simpl; auto.
Qed.

Lemma napply_app s n u v : napply s n (u++v) = napply s n u ++ napply s n v.
Proof.
 revert u v. induction n; intros; simpl; auto.
 now rewrite apply_app, IHn.
Qed.

Lemma napply_cons s n a u : napply s n (a::u) = napply s n [a] ++ napply s n u.
Proof.
 apply (napply_app s n [a] u).
Qed.

Lemma napply_alt s n u : napply s (S n) u = apply s (napply s n u).
Proof.
 revert u.
 induction n; intros; simpl; auto.
 now rewrite <- IHn.
Qed.

Lemma napply_add s n m u : napply s (n+m) u = napply s n (napply s m u).
Proof.
 induction n.
 - simpl; auto.
 - now rewrite Nat.add_succ_l, !napply_alt, IHn.
Qed.

Lemma napply_concat s n w :
  napply s n w = concat (map (fun a => napply s n [a]) w).
Proof.
 induction w; simpl; auto using napply_nil.
 rewrite napply_cons. now f_equal.
Qed.

Definition NoErase (s:subst) := forall a, s a <> [].

Definition Prolong (s:subst) a := exists u, u<>[] /\ s a = a::u.

Lemma noerase_nonnil_apply s u : NoErase s -> u<>[] -> apply s u <> [].
Proof.
 intros NE. destruct u as [|a u]. easy. intros _. simpl.
 specialize (NE a). destruct (s a) as [|b v]; easy.
Qed.

Lemma noerase_nonnil_napply s u n : NoErase s -> u<>[] -> napply s n u <> [].
Proof.
 intros NE. revert u. induction n; simpl; intros; auto.
 apply IHn. apply noerase_nonnil_apply; auto.
Qed.

Lemma noerase_prolong_napply_len s a :
  NoErase s -> Prolong s a -> forall n, n < length (napply s n [a]).
Proof.
 intros NE (u & Hu & PR).
 induction n. simpl; auto.
 simpl. rewrite app_nil_r, PR, napply_cons, app_length.
 assert (length (napply s n u) <> 0).
 { rewrite length_zero_iff_nil. now apply noerase_nonnil_napply. }
 lia.
Qed.

Lemma napply_prefix_S s a n :
 Prolong s a -> Prefix (napply s n [a]) (napply s (S n) [a]).
Proof.
 intros (u & Hu & PR).
 simpl. rewrite app_nil_r, PR. rewrite (napply_cons _ _ _ u).
 now exists (napply s n u).
Qed.

Lemma napply_prefix_mono s a n m : Prolong s a -> n <= m ->
 Prefix (napply s n [a]) (napply s m [a]).
Proof.
 intros PR.
 induction 1.
 - exists []. apply app_nil_r.
 - destruct IHle as (w & E).
   destruct (napply_prefix_S s a m) as (w' & E'); auto.
   exists (w++w'). now rewrite app_assoc, E, E'.
Qed.

Lemma apply_grow s w : NoErase s -> length w <= length (apply s w).
Proof.
 intros NE.
 induction w; simpl; auto.
 rewrite app_length. specialize (NE a). destruct (s a); simpl; lia || easy.
Qed.

Lemma napply_mono s n m w :
 NoErase s -> n <= m -> length (napply s n w) <= length (napply s m w).
Proof.
 induction 2; auto.
 rewrite IHle. clear IHle H0. rewrite napply_alt. now apply apply_grow.
Qed.

(** Any nonerasing prolongeable substitution leads to a unique infinite
    sequence *)

Definition SubstSeq (s:subst) (f:seq) a :=
  forall n, PrefixSeq (napply s n [a]) f.

Definition subst2seq s a :=
 fun n => nth n (napply s n [a]) a.

Lemma subst2seq_indep s a n : NoErase s -> Prolong s a ->
  forall m, n <= m -> subst2seq s a n = nth n (napply s m [a]) a.
Proof.
 intros. apply Prefix_nth. apply napply_prefix_mono; auto.
 apply noerase_prolong_napply_len; auto.
Qed.

Lemma substseq_exists s a :
  NoErase s -> Prolong s a -> SubstSeq s (subst2seq s a) a.
Proof.
 intros NE PR n.
 red. symmetry. apply take_carac; auto.
 intros m b Hm.
 unfold subst2seq.
 rewrite (nth_indep _ b a); auto.
 destruct (Nat.le_gt_cases n m).
 - apply Prefix_nth; auto.
   apply napply_prefix_mono; auto.
 - symmetry.
   apply Prefix_nth; auto.
   apply napply_prefix_mono; auto with arith.
   apply noerase_prolong_napply_len; auto.
Qed.

Lemma substseq_unique s a f f' :
  NoErase s -> Prolong s a -> SubstSeq s f a -> SubstSeq s f' a ->
  (forall n, f n = f' n).
Proof.
 intros NE PR Hf Hf' n.
 specialize (Hf (S n)).
 specialize (Hf' (S n)). unfold PrefixSeq in *.
 set (u := napply s (S n) [a]) in *.
 rewrite <- (take_nth f (length u) n a).
 2:{ transitivity (S n); auto. apply noerase_prolong_napply_len; auto. }
 rewrite <- (take_nth f' (length u) n a); auto.
 2:{ transitivity (S n); auto. apply noerase_prolong_napply_len; auto. }
 now rewrite <- Hf, <- Hf'.
Qed.

(* Auxiliary result *)

Lemma seq_S a b : List.seq a (S b) = List.seq a b ++ [a+b].
Proof.
 revert a.
 induction b; simpl; intros. f_equal; lia.
 rewrite Nat.add_succ_r, <- Nat.add_succ_l. now rewrite <- IHb.
Qed.

(** Specific susbstitution for Hofstadter functions.
    Works on letters 0..k *)

Definition ksubst k n := if n =? k then [k; 0] else [S n].

Definition kword k n := napply (ksubst k) n [k].

Definition kseq k := subst2seq (ksubst k) k.

(* Compute map (kseq 2) (List.seq 0 20). *)
(* [2; 0; 1; 2; 2; 0; 2; 0; 1; 2; 0; 1; 2; 2; 0; 1; 2; 2; 0; 2] *)

Lemma ksubst_noerase k : NoErase (ksubst k).
Proof.
 red. intros c. unfold ksubst. now case Nat.eqb_spec.
Qed.

Lemma ksubst_prolong k : Prolong (ksubst k) k.
Proof.
 red. exists [0]. split. easy.
 unfold ksubst. now rewrite Nat.eqb_refl.
Qed.

Lemma kseq_SubstSeq k : SubstSeq (ksubst k) (kseq k) k.
Proof.
 apply substseq_exists. apply ksubst_noerase. apply ksubst_prolong.
Qed.

Lemma kword_S k n : kword k (S n) = apply (ksubst k) (kword k n).
Proof.
 apply napply_alt.
Qed.

(** kword letters are always in 0..k *)

Lemma ksubst_letters k w :
 Forall (fun a => a <= k) w ->
 Forall (fun a => a <= k) (apply (ksubst k) w).
Proof.
 induction w; simpl; auto.
 intros H; inversion_clear H. apply Forall_app. split; auto.
 unfold ksubst.
 case Nat.eqb_spec; intro; repeat (constructor; try lia).
Qed.

Lemma kword_letters k n : Forall (fun a => a <= k) (kword k n).
Proof.
 unfold kword. induction n.
 - simpl. now constructor.
 - rewrite napply_alt. now apply ksubst_letters.
Qed.

(** Initial values *)

Lemma kword_0 k : kword k 0 = [k].
Proof.
 reflexivity.
Qed.

Lemma kword_1 k : kword k 1 = [k;0].
Proof.
 cbn. unfold ksubst. now rewrite Nat.eqb_refl.
Qed.

Lemma ksubst_low0 k n : n <= k -> napply (ksubst k) n [0] = [n].
Proof.
 induction n. auto.
 intros LE.
 rewrite napply_alt. rewrite IHn; try lia. simpl.
 unfold ksubst. case Nat.eqb_spec. lia. intros _. apply app_nil_r.
Qed.

Lemma kword_low k n : n <= S k -> kword k n = k :: List.seq 0 n.
Proof.
 induction n.
 - now rewrite kword_0.
 - intros LE.
   rewrite seq_S.
   cbn. unfold ksubst at 2. rewrite Nat.eqb_refl. simpl.
   rewrite napply_cons.
   rewrite ksubst_low0; auto; try lia.
   change (kword k n ++ [n] = k  :: List.seq 0 n ++ [n]).
   rewrite IHn; try lia. auto.
Qed.

(** Alt equation : *)

Lemma kword_alt k n : k<=n -> kword k (S n) = kword k n ++ kword k (n-k).
Proof.
 induction n.
 - intros. replace k with 0 by lia. simpl; auto.
 - intros LE. apply Nat.lt_eq_cases in LE. destruct LE as [LT|EQ].
   + replace (S n -k) with (S (n-k)) by lia.
     remember (S n) as m eqn:E.
     cbn.
     rewrite app_nil_r.
     unfold ksubst at 2. rewrite Nat.eqb_refl.
     rewrite napply_cons. f_equal.
     replace m with (m-k+k) by lia.
     rewrite napply_add. rewrite ksubst_low0 by lia. simpl.
     replace (m-k) with (S (n-k)) by lia.
     simpl. now rewrite app_nil_r.
   + rewrite <- EQ. replace (k-k) with 0 by lia.
     rewrite kword_0. cbn.
     unfold ksubst at 2. rewrite Nat.eqb_refl, app_nil_r.
     rewrite napply_cons. f_equal. apply ksubst_low0. lia.
Qed.

Lemma kword_len k n : length (kword k n) = A k n.
Proof.
 induction n as [[|n] IH] using lt_wf_ind.
 - now rewrite kword_0.
 - case (Nat.le_gt_cases k n) as [LE|GT].
   + rewrite kword_alt; auto. rewrite app_length, !IH; try lia.
     simpl; auto.
   + rewrite kword_low by auto. simpl.
     rewrite seq_length. rewrite !A_base; lia.
Qed.

Lemma kseq_alt k n m a : n < A k m -> kseq k n = nth n (kword k m) a.
Proof.
 intros LE.
 rewrite (kseq_SubstSeq k m).
 change (napply _ _ _) with (kword k m).
 rewrite kword_len, take_nth; auto.
Qed.

Lemma kseq_take_A k n : take (A k n) (kseq k) = kword k n.
Proof.
 apply take_carac.
 - apply kword_len.
 - intros. symmetry. now apply kseq_alt.
Qed.

(** Link between [kseq] and Zeckendorf decomposition :
    0 iff rank 0,
    1 iff rank 1,
    ...
    k iff rank >= k (or no rank, ie n=0)

    Hence 0 in [kseq] whenever the [f k] function is flat.
*)

Definition omin (oa:option nat) (b:nat) :=
  match oa with
  | None => b
  | Some a => Nat.min a b
  end.

Definition bounded_rank k n := omin (rank k n) k.

Lemma kseq_bounded_rank k n : kseq k n = bounded_rank k n.
Proof.
 induction n as [n IH] using lt_wf_ind.
 assert (E := decomp_sum k n).
 assert (D := decomp_delta k n).
 set (l := decomp k n) in *.
 destruct (rev l) as [|a rl] eqn:E'; apply rev_switch in E'.
 - rewrite E' in *. simpl in E. rewrite <- E. easy.
 - assert (A k a <= n < A k (S a)).
   { rewrite <- E, E', sumA_rev.
     split.
     + simpl; lia.
     + apply decomp_max. apply Delta_rev. now rewrite <- E'. }
   rewrite (kseq_alt k n (S a) 0) by lia.
   destruct (Nat.lt_ge_cases a k) as [LT|LE].
   + rewrite kword_low by lia.
     destruct n as [|n]; try easy.
     change (nth _ _ _) with (nth n (List.seq 0 (S a)) 0).
     rewrite !A_base in H; try lia.
     replace n with a by lia.
     rewrite seq_nth by lia. simpl.
     unfold bounded_rank, rank. rewrite decomp_low; simpl; lia.
   + rewrite kword_alt by auto.
     rewrite app_nth2; rewrite kword_len; try lia.
     rewrite <- kseq_alt by (simpl in H; lia).
     rewrite IH by (generalize (@A_nz k a); lia).
     unfold bounded_rank, rank. fold l; rewrite E'; simpl rev.
     replace (decomp _ _) with (rev rl).
     2:{ symmetry; apply decomp_carac.
         - rewrite E' in D. simpl in D. now apply Delta_app_iff in D.
         - revert E. rewrite E'. simpl. rewrite sumA_app. simpl. lia. }
     destruct (rev rl); simpl; lia.
Qed.

(** Another possible susbstitution for Hofstadter functions,
    giving [min (rank n) (S k)] instead of [min (rank n) k].
    Hence it works on 0..(S k) instead of 0..k *)

Definition ksubstbis k n := if n <? k then [S n] else [S k; 0].

Definition kwordbis k n := napply (ksubstbis k) n [S k].

Definition kseqbis k := subst2seq (ksubstbis k) (S k).

(* Compute map (kseqbis 2) (List.seq 0 20). *)
(* [3; 0; 1; 2; 3; 0; 3; 0; 1; 3; 0; 1; 2; 3; 0; 1; 2; 3; 0; 3] *)

Lemma ksubstbis_noerase k : NoErase (ksubstbis k).
Proof.
 red. intros c. unfold ksubstbis. now case Nat.ltb_spec.
Qed.

Lemma ksubstbis_prolong k : Prolong (ksubstbis k) (S k).
Proof.
 red. exists [0]. split. easy.
 unfold ksubstbis. case Nat.ltb_spec; auto; lia.
Qed.

Lemma kseqbis_SubstSeq k : SubstSeq (ksubstbis k) (kseqbis k) (S k).
Proof.
 apply substseq_exists. apply ksubstbis_noerase. apply ksubstbis_prolong.
Qed.

(** Initial values *)

Lemma kwordbis_0 k : kwordbis k 0 = [S k].
Proof.
 reflexivity.
Qed.

Lemma kwordbis_1 k : kwordbis k 1 = [S k; 0].
Proof.
 cbn. unfold ksubstbis.
 case Nat.ltb_spec; auto. lia.
Qed.

Lemma ksubstbis_low0 k n : n <= k -> napply (ksubstbis k) n [0] = [n].
Proof.
 induction n. auto.
 intros LE.
 rewrite napply_alt. rewrite IHn; try lia. simpl.
 unfold ksubstbis. case Nat.ltb_spec; auto. lia.
Qed.

Lemma ksubstbis_low0' k : napply (ksubstbis k) (S k) [0] = [S k; 0].
Proof.
 change (S k) with (1+k) at 1. rewrite napply_add.
 rewrite ksubstbis_low0 by lia. simpl.
 unfold ksubstbis. case Nat.ltb_spec; auto. lia.
Qed.

Lemma kwordbis_low k n : n <= S k -> kwordbis k n = S k :: List.seq 0 n.
Proof.
 induction n.
 - now rewrite kwordbis_0.
 - intros LE.
   rewrite seq_S.
   cbn. unfold ksubstbis at 2. case Nat.ltb_spec; try lia. intros _.
   simpl. rewrite napply_cons.
   rewrite ksubstbis_low0; auto; try lia.
   change (kwordbis k n ++ [n] = S k :: List.seq 0 n ++ [n]).
   rewrite IHn; try lia. auto.
Qed.

(** Alt equation : *)

Lemma kwordbis_alt k n :
  k<n -> kwordbis k (S n) = kwordbis k n ++ kwordbis k (n-k).
Proof.
 induction n.
 - inversion 1.
 - rewrite Nat.lt_succ_r, Nat.lt_eq_cases.
   intros [LT| <-].
   + replace (S n -k) with (S (n-k)) by lia.
     remember (S n) as m eqn:E.
     cbn.
     rewrite app_nil_r.
     unfold ksubstbis at 2. case Nat.ltb_spec; try lia. intros _.
     rewrite napply_cons. f_equal.
     replace m with (m-k+k) by lia.
     rewrite napply_add. rewrite ksubstbis_low0 by lia.
     replace (m-k) with (S (n-k)) by lia.
     simpl. f_equal. unfold ksubstbis.
     do 2 (case Nat.ltb_spec; try lia). auto.
   + clear IHn.
     replace (S k-k) with 1 by lia. rewrite kwordbis_1.
     remember (S k) as m eqn:E.
     unfold kwordbis at 1. simpl. unfold ksubstbis at 2.
     case Nat.ltb_spec; try lia. intros _. simpl.
     rewrite napply_cons. f_equal. subst m. apply ksubstbis_low0'.
Qed.

Lemma kwordbis_len k n : length (kwordbis k n) = A k n.
Proof.
 induction n as [[|n] IH] using lt_wf_ind.
 - now rewrite kwordbis_0.
 - case (Nat.lt_ge_cases k n) as [LT|GE].
   + rewrite kwordbis_alt; auto. rewrite app_length, !IH; try lia.
     simpl; auto.
   + rewrite kwordbis_low by lia. simpl.
     rewrite seq_length. rewrite !A_base; lia.
Qed.

Lemma kseqbis_alt k n m a : n < A k m -> kseqbis k n = nth n (kwordbis k m) a.
Proof.
 intros LE.
 rewrite (kseqbis_SubstSeq k m).
 change (napply _ _ _) with (kwordbis k m).
 rewrite kwordbis_len, take_nth; auto.
Qed.

(** Link between [kseqbis] and Zeckendorf decomposition :
    0 iff rank 0,
    1 iff rank 1,
    ...
    (S k) iff rank > k (or no rank, ie n=0)

    Hence 0 in [kseqbis] whenever the [f k] function is flat.
*)

Definition bounded_rankbis k n := omin (rank k n) (S k).

Lemma kseqbis_bounded_rank k n : kseqbis k n = bounded_rankbis k n.
Proof.
 induction n as [n IH] using lt_wf_ind.
 assert (E := decomp_sum k n).
 assert (D := decomp_delta k n).
 set (l := decomp k n) in *.
 destruct (rev l) as [|a rl] eqn:E'; apply rev_switch in E'.
 - rewrite E' in *. simpl in E. rewrite <- E. easy.
 - assert (A k a <= n < A k (S a)).
   { rewrite <- E, E', sumA_rev.
     split.
     + simpl; lia.
     + apply decomp_max. apply Delta_rev. now rewrite <- E'. }
   rewrite (kseqbis_alt k n (S a) 0) by lia.
   destruct (Nat.le_gt_cases a k) as [LE|LT].
   + rewrite kwordbis_low by lia.
     destruct n as [|n]; try easy.
     change (nth _ _ _) with (nth n (List.seq 0 (S a)) 0).
     rewrite !A_base in H; try lia.
     replace n with a by lia.
     rewrite seq_nth by lia. simpl.
     unfold bounded_rankbis, rank. rewrite decomp_low; simpl; lia.
   + rewrite kwordbis_alt by auto.
     rewrite app_nth2; rewrite kwordbis_len; try lia.
     rewrite <- kseqbis_alt by (simpl in H; lia).
     rewrite IH by (generalize (@A_nz k a); lia).
     unfold bounded_rankbis, rank. fold l; rewrite E'; simpl rev.
     replace (decomp _ _) with (rev rl).
     2:{ symmetry; apply decomp_carac.
         - rewrite E' in D. simpl in D. now apply Delta_app_iff in D.
         - revert E. rewrite E'. simpl. rewrite sumA_app. simpl. lia. }
     destruct (rev rl); simpl; lia.
Qed.

Lemma kseqbis_kseq k n : kseq k n = Nat.min k (kseqbis k n).
Proof.
 rewrite kseq_bounded_rank, kseqbis_bounded_rank.
 unfold bounded_rank, bounded_rankbis.
 destruct rank; simpl; lia.
Qed.

(** Counting letter a in word w *)

Fixpoint nbocc a w :=
 match w with
 | [] => 0
 | b::w' => nbocc a w' + if b =? a then 1 else 0
 end.

Lemma nbocc_app a u v : nbocc a (u++v) = nbocc a u + nbocc a v.
Proof.
 induction u; simpl; auto; lia.
Qed.

Fixpoint natsum f n :=
  match n with
  | 0 => 0
  | S n => f n + natsum f n
  end.

Lemma natsum_ext f g n :
  (forall m, m < n -> f m = g m) ->
  natsum f n = natsum g n.
Proof.
 revert f g. induction n; simpl; auto.
 intros f g E. f_equal; auto.
Qed.

Lemma natsum_0 n : natsum (fun _ => 0) n = 0.
Proof.
 induction n; simpl; auto.
Qed.

Lemma natsum_add f g n :
 natsum (fun m => f m + g m) n = natsum f n + natsum g n.
Proof.
 induction n; simpl; auto. rewrite IHn; lia.
Qed.

Lemma natsum_test a n : a < n ->
 natsum (fun m : nat => if a =? m then 1 else 0) n = 1.
Proof.
 revert a. induction n; intros a Ha.
 - lia.
 - simpl. case Nat.eqb_spec.
   + intros ->. simpl. f_equal. erewrite natsum_ext. apply natsum_0.
     intros; simpl. case Nat.eqb_spec; lia.
   + intros. simpl. apply IHn; lia.
Qed.

Lemma nbocc_total_lt u k :
  Forall (fun n => n < k) u ->
  length u = natsum (fun n => nbocc n u) k.
Proof.
 induction u; simpl; intros H.
 - now rewrite natsum_0.
 - inversion_clear H. rewrite natsum_add. rewrite IHu by trivial.
   rewrite natsum_test; simpl; lia.
Qed.

Lemma nbocc_total_le u k :
  Forall (fun n => n <= k) u ->
  length u = natsum (fun n => nbocc n u) (S k).
Proof.
 intros H. apply nbocc_total_lt. eapply Forall_impl; eauto.
 simpl; intros; lia.
Qed.

Definition listsum l := List.fold_right Nat.add 0 l.

Lemma listsum_cons x l : listsum (x::l) = x + listsum l.
Proof.
 reflexivity.
Qed.

Lemma listsum_app l l' : listsum (l++l') = listsum l + listsum l'.
Proof.
 induction l; simpl; rewrite ?IHl; lia.
Qed.

Lemma listsum_rev l : listsum (rev l) = listsum l.
Proof.
 induction l; simpl; auto.
 rewrite listsum_app, IHl. simpl; lia.
Qed.

Lemma nbocc_concat a l :
 nbocc a (concat l) = listsum (map (nbocc a) l).
Proof.
 induction l as [|w l IH]; simpl; auto.
 rewrite nbocc_app. now f_equal.
Qed.

(** Counting letter 0 in [kseq k] leads back to the [f k] fonction.
    [count f a n] is the number of letter [a] in [(f 0) .. (f (pred n))]. *)

Fixpoint count f a n :=
 match n with
 | 0 => 0
 | S n => count f a n + if f n =? a then 1 else 0
 end.

Lemma count_nbocc f a n : count f a n = nbocc a (take n f).
Proof.
 induction n; simpl; auto.
 rewrite nbocc_app. simpl. now f_equal.
Qed.

Lemma f_count_0 k n : k<>0 -> count (kseq k) 0 n + f k n = n.
Proof.
 induction n.
 - easy.
 - simpl. intros Hk.
   rewrite kseq_bounded_rank.
   unfold bounded_rank.
   destruct (f_step k n) as [E|E].
   + rewrite E. rewrite flat_rank_0 in E. rewrite E. simpl. lia.
   + rewrite E. rewrite step_rank_nz in E.
     destruct (rank k n) as [[|r]|]; simpl; try easy;
       destruct k; simpl; auto; try lia.
Qed.

(** Similarly, counting all letters above [p] leads to [(f k)^^p],
    the p-iterate of [f k]. *)

Fixpoint count_above f a n :=
 match n with
 | 0 => 0
 | S n => count_above f a n + if a <=? f n then 1 else 0
 end.

Lemma fs_count_above k p n :
  p <= k -> (f k ^^p) n = count_above (kseq k) p n.
Proof.
 intros Hp.
 induction n.
 - simpl. apply fs_k_0.
 - simpl. rewrite kseq_bounded_rank.
   unfold bounded_rank.
   destruct (fs_step k p n) as [E|E].
   + rewrite E. rewrite fs_flat_low_rank in E by lia.
     destruct (rank k n); simpl; try easy.
     red in E. case Nat.leb_spec; lia.
   + rewrite E. rewrite fs_nonflat_high_rank in E by lia.
     destruct (rank k n); simpl in *; case Nat.leb_spec; lia.
Qed.

(* Particular case : p=k *)

Lemma count_above_kseq_k k n :
  count_above (kseq k) k n = count (kseq k) k n.
Proof.
 induction n; simpl; auto.
 rewrite kseq_bounded_rank. unfold bounded_rank.
 destruct (rank k n); simpl in *; case Nat.leb_spec; case Nat.eqb_spec; lia.
Qed.

Lemma fs_count_k k n : (f k ^^k) n = count (kseq k) k n.
Proof.
 rewrite fs_count_above by lia.
 apply count_above_kseq_k.
Qed.

(* From a Prefix of napply of a word to a prefix of napply of a letter *)

Lemma napply_prefix s n u v :
  NoErase s -> v<>[] ->
  Prefix u (napply s n v) ->
  exists w t a,
    Prefix (w++[a]) v /\ u = napply s n w ++ t /\ Prefix t (napply s n [a]).
Proof.
 intros NE. revert u.
 induction v; try easy.
 - intros u _. rewrite napply_cons. intros Pr.
   apply Prefix_app in Pr. destruct Pr as [Pr|(u' & E & Pr)].
   + exists [], u, a. rewrite napply_nil. simpl. split; auto. now exists v.
   + destruct (list_eq_dec Nat.eq_dec v []) as [->|NE'].
     * rewrite napply_nil in Pr. apply Prefix_nil in Pr. subst u'.
       rewrite app_nil_r in E.
       exists [], u, a. rewrite napply_nil.
       repeat split; subst; auto using Prefix_id.
     * destruct (IHv u' NE' Pr) as (w & t & b & Hv & E' & Ht).
       exists (a::w), t, b. repeat split; auto.
       { simpl. now apply Prefix_cons. }
       { now rewrite napply_cons, app_ass, <- E', <- E. }
Qed.

(* Saari's Lemma 4 : decomposition of a prefix of s^n(a) *)

Definition Bound s n N := forall a:letter, length (napply s n [a]) <= N.

Lemma Saari_lemma4 s a n w G M1 MG : G<>0 -> n<>0 ->
 Bound s 1 M1 -> Bound s G MG ->
 NoErase s ->
 Prefix w (napply s n [a]) ->
 exists l : list (nat * word), exists z,
  w = concat (map (fun '(ni,ui) => napply s ni ui) l) ++ z
  /\ Forall (fun '(ni,ui) => length ui <= M1 /\ G <= ni < n) l
  /\ DeltaRev 1 (map fst l)
  /\ length z <= MG.
Proof.
 intros HG. revert a w.
 induction n as [n IH] using lt_wf_ind.
 intros a w Hn B1 BG NE Pr.
 destruct (Nat.le_gt_cases n G).
 - exists []. exists w. simpl. repeat split; auto. constructor.
   apply Prefix_len in Pr.
   etransitivity; [apply Pr|]. red in BG.
   rewrite <- (BG a). now apply napply_mono.
 - destruct n as [|n]; try easy.
   simpl in Pr. rewrite app_nil_r in Pr.
   destruct (napply_prefix s n w (s a) NE (NE a) Pr)
     as (w1 & w2 & b & H1 & H2 & H3).
   destruct (IH n (Nat.lt_succ_diag_r n) b w2)
     as (l & z & EQ & F & D & LE); auto; try lia.
   exists ((n,w1)::l), z; repeat split; auto.
   + simpl. now rewrite app_ass, <-EQ.
   + constructor; try split; auto; try lia.
     * rewrite <- (B1 a). simpl. rewrite app_nil_r.
       apply Prefix_len in H1. rewrite app_length in H1. simpl in H1. lia.
     * clear -F. rewrite Forall_forall in *.
       intros (m,u) IN. apply F in IN. lia.
   + simpl. apply DeltaRev_alt. split; auto.
     intros y. rewrite in_map_iff. intros ((m,y') & <- & IN). simpl.
     rewrite Forall_forall in F. apply F in IN. lia.
Qed.

(* Full decomposition of any prefix of kword, then kseq *)

Lemma decomp_prefix_kword k w n l :
 Prefix w (kword k n) ->
 l = rev (decomp k (length w)) ->
 w = concat (map (kword k) l).
Proof.
 revert w l. induction n as [n IH] using lt_wf_ind.
 intros w l P.
 destruct (Nat.le_gt_cases n (S k)).
 - clear IH. rewrite kword_low in * by trivial.
   destruct (Prefix_cons_inv _ _ _ P) as [->|(w' & E' & P')].
   + simpl. now intros ->.
   + assert (LE := Prefix_len _ _ P'). rewrite seq_length in LE.
     apply Prefix_seq in P'.
     rewrite E'. simpl length. set (p := length w') in *.
     rewrite decomp_low by lia.
     replace (S _ -1) with p by lia. intros ->. simpl.
     rewrite kword_low, <-P', app_nil_r by lia. trivial.
 - assert (P' := P). destruct P' as ([|a u] & E).
   + rewrite app_nil_r in E. rewrite E. rewrite kword_len.
     replace (decomp k (A k n)) with [n].
     2:{ symmetry; apply decomp_carac; try constructor; simpl; auto. }
     intros ->. simpl. now rewrite app_nil_r.
   + assert (LT : length w < A k n).
     { rewrite <- kword_len, <- E, app_length. simpl. lia. }
     clear  E.
     destruct n; [lia|].
     rewrite kword_alt in P by lia.
     apply Prefix_app in P. destruct P as [P|(w' & -> & P)].
     * apply (IH n); auto.
     * rewrite app_length, kword_len in *.
       rewrite Nat.add_comm, decomp_plus_A by (simpl in LT; lia).
       rewrite rev_app_distr. intros ->. simpl.
       f_equal. apply (IH (n-k)); auto. lia.
Qed.

Lemma decomp_prefix_kseq k n :
 take n (kseq k) = concat (map (kword k) (rev (decomp k n))).
Proof.
 assert (H := invA_spec k n). set (m := invA k n) in *.
 assert (H' : n <= A k (S m)) by lia. clear H. clearbody m.
 apply (decomp_prefix_kword _ _ (S m)).
 - apply Prefix_nth. intros p a. rewrite take_length. intros LT.
   rewrite take_nth by trivial.
   apply kseq_alt; lia.
 - now rewrite take_length.
Qed.

Lemma count_kseq_decomp k n a :
 count (kseq k) a n =
  listsum (map (fun m => nbocc a (kword k m)) (decomp k n)).
Proof.
 rewrite count_nbocc, decomp_prefix_kseq, nbocc_concat.
 now rewrite map_map, map_rev, listsum_rev.
Qed.

(* Special case k=2

 0 -> 1
 1 -> 2
 2 -> 20

 Occurrence matrix :

 001
 100
 011

*)

Lemma nbocc_ksubst2 w :
 let s := apply (ksubst 2) in
 nbocc 0 (s w) = nbocc 2 w /\
 nbocc 1 (s w) = nbocc 0 w /\
 nbocc 2 (s w) = nbocc 1 w + nbocc 2 w.
Proof.
 induction w; simpl; auto.
 rewrite !nbocc_app.
 destruct IHw as (-> & -> & ->).
 destruct a as [|[|[|n]]]; simpl; lia.
Qed.

Definition tripleocc w := (nbocc 0 w, nbocc 1 w, nbocc 2 w).

Definition occurmatrix '(x,y,z) : nat*nat*nat := (z,x,y+z).

Lemma nbocc_ksubst2_bis w :
 tripleocc (apply (ksubst 2) w) = occurmatrix (tripleocc w).
Proof.
 unfold tripleocc.
 now destruct (nbocc_ksubst2 w) as (-> & -> & ->).
Qed.

Lemma len_alt w :
  Forall (fun a => a <= 2) w ->
  length w = nbocc 0 w + nbocc 1 w + nbocc 2 w.
Proof.
 intros. rewrite nbocc_total_le with (k:=2); simpl; auto; lia.
Qed.

Lemma len_ksubst2 w :
 length (apply (ksubst 2) w) = length w + nbocc 2 w.
Proof.
 induction w; simpl; auto.
 rewrite app_length, IHw.
 unfold ksubst at 1.
 case Nat.eqb_spec; simpl; lia.
Qed.
