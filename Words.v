Require Import MoreTac MoreFun MoreList DeltaList GenFib GenG.
Import ListNotations.

(** * Morphic words

    Some theory of infinite words generated by substitutions.
    Hofstadter functions [f k] can be described by such infinite words.
*)

(** letters : here some natural numbers.
    Most of the time, we'll only use 0..k-1 for some parameter k. *)

Notation letter := nat (only parsing).

(** Finite word : list of letters *)

Definition word := list letter.

(** Sequence a.k.a Infinite word : function from nat to letter *)

Definition sequence := nat -> letter.

Definition PrefixSeq (u:word) (f:sequence) := u = take (length u) f.

(** Substitution : function form letter to words *)

Definition subst := letter -> word.

Definition apply : subst -> word -> word := @flat_map _ _.

Fixpoint napply (s:subst) n w :=
  match n with
  | 0 => w
  | S n => napply s n (apply s w)
  end.

Lemma napply_is_iter s n w : napply s n w = (apply s ^^n) w.
Proof.
 revert w.
 induction n; auto. intros. now rewrite iter_S, <- IHn.
Qed.

Lemma napply_1 s u : napply s 1 u = apply s u.
Proof.
 reflexivity.
Qed.

Lemma apply_app s u v : apply s (u++v) = apply s u ++ apply s v.
Proof.
 apply flat_map_app.
Qed.

Lemma apply_alt s w : apply s w = concat (map s w).
Proof.
 apply flat_map_concat_map.
Qed.

Lemma napply_nil s n : napply s n [] = [].
Proof.
 induction n; simpl; auto.
Qed.

Lemma napply_app s n u v : napply s n (u++v) = napply s n u ++ napply s n v.
Proof.
 revert u v. induction n; intros; simpl; auto.
 now rewrite apply_app, IHn.
Qed.

Lemma napply_cons s n a u : napply s n (a::u) = napply s n [a] ++ napply s n u.
Proof.
 apply (napply_app s n [a] u).
Qed.

Lemma napply_alt s n u : napply s (S n) u = apply s (napply s n u).
Proof.
 revert u.
 induction n; intros; simpl; auto.
 now rewrite <- IHn.
Qed.

Lemma napply_add s n m u : napply s (n+m) u = napply s n (napply s m u).
Proof.
 induction n.
 - simpl; auto.
 - now rewrite Nat.add_succ_l, !napply_alt, IHn.
Qed.

Lemma napply_flat_map s n w :
  napply s n w = flat_map (fun a => napply s n [a]) w.
Proof.
 induction w; simpl; auto using napply_nil.
 rewrite napply_cons. now f_equal.
Qed.

Lemma Prefix_apply s u v :
  Prefix u v -> Prefix (apply s u) (apply s v).
Proof.
 intros (w, <-). rewrite apply_app. now eexists.
Qed.

Lemma Prefix_napply s n u v :
  Prefix u v -> Prefix (napply s n u) (napply s n v).
Proof.
 intros (w, <-). rewrite napply_app. now eexists.
Qed.

Definition NoErase (s:subst) := forall a, s a <> [].

Definition Prolong (s:subst) a := exists u, u<>[] /\ s a = a::u.

Lemma noerase_nonnil_apply s u : NoErase s -> u<>[] -> apply s u <> [].
Proof.
 intros NE. destruct u as [|a u]. easy. intros _. simpl.
 specialize (NE a). destruct (s a) as [|b v]; easy.
Qed.

Lemma noerase_nonnil_napply s u n : NoErase s -> u<>[] -> napply s n u <> [].
Proof.
 intros NE. revert u. induction n; simpl; intros; auto.
 apply IHn. apply noerase_nonnil_apply; auto.
Qed.

Lemma noerase_prolong_napply_len s a :
  NoErase s -> Prolong s a -> forall n, n < length (napply s n [a]).
Proof.
 intros NE (u & Hu & PR).
 induction n. simpl; auto.
 simpl. rewrite app_nil_r, PR, napply_cons, app_length.
 assert (length (napply s n u) <> 0).
 { rewrite length_zero_iff_nil. now apply noerase_nonnil_napply. }
 lia.
Qed.

Lemma napply_prefix_S s a n :
 Prolong s a -> Prefix (napply s n [a]) (napply s (S n) [a]).
Proof.
 intros (u & Hu & PR).
 simpl. rewrite app_nil_r, PR. rewrite (napply_cons _ _ _ u).
 now exists (napply s n u).
Qed.

Lemma napply_prefix_mono s a n m : Prolong s a -> n <= m ->
 Prefix (napply s n [a]) (napply s m [a]).
Proof.
 intros PR.
 induction 1.
 - exists []. apply app_nil_r.
 - destruct IHle as (w & E).
   destruct (napply_prefix_S s a m) as (w' & E'); auto.
   exists (w++w'). now rewrite app_assoc, E, E'.
Qed.

Lemma apply_grow s w : NoErase s -> length w <= length (apply s w).
Proof.
 intros NE.
 induction w; simpl; auto.
 rewrite app_length. specialize (NE a). destruct (s a); simpl; lia || easy.
Qed.

Lemma napply_mono s n m w :
 NoErase s -> n <= m -> length (napply s n w) <= length (napply s m w).
Proof.
 induction 2; auto.
 rewrite IHle. clear IHle H0. rewrite napply_alt. now apply apply_grow.
Qed.

(** Any nonerasing prolongeable substitution leads to a unique infinite
    sequence *)

Definition SubstSeq (s:subst) (f:sequence) a :=
  forall n, PrefixSeq (napply s n [a]) f.

Definition subst2seq s a :=
 fun n => nth n (napply s n [a]) a.

Lemma subst2seq_indep s a b n : NoErase s -> Prolong s a ->
  forall m, n <= m -> subst2seq s a n = nth n (napply s m [a]) b.
Proof.
 intros. rewrite nth_indep with (d':=a).
 2:{ apply Nat.le_lt_trans with m; trivial.
     apply noerase_prolong_napply_len; trivial. }
 apply Prefix_nth. apply napply_prefix_mono; auto.
 apply noerase_prolong_napply_len; auto.
Qed.

Lemma substseq_exists s a :
  NoErase s -> Prolong s a -> SubstSeq s (subst2seq s a) a.
Proof.
 intros NE PR n.
 red. symmetry. apply take_carac; auto.
 intros m b Hm.
 unfold subst2seq.
 rewrite (nth_indep _ b a); auto.
 destruct (Nat.le_gt_cases n m).
 - apply Prefix_nth; auto.
   apply napply_prefix_mono; auto.
 - symmetry.
   apply Prefix_nth; auto.
   apply napply_prefix_mono; auto with arith.
   apply noerase_prolong_napply_len; auto.
Qed.

Lemma substseq_unique s a f f' :
  NoErase s -> Prolong s a -> SubstSeq s f a -> SubstSeq s f' a ->
  (forall n, f n = f' n).
Proof.
 intros NE PR Hf Hf' n.
 specialize (Hf (S n)).
 specialize (Hf' (S n)). unfold PrefixSeq in *.
 set (u := napply s (S n) [a]) in *.
 rewrite <- (take_nth f (length u) n a).
 2:{ transitivity (S n); auto. apply noerase_prolong_napply_len; auto. }
 rewrite <- (take_nth f' (length u) n a); auto.
 2:{ transitivity (S n); auto. apply noerase_prolong_napply_len; auto. }
 now rewrite <- Hf, <- Hf'.
Qed.

(** Specific susbstitution for Hofstadter functions.
    Works on letters 0..k-1 *)

Definition ksubst k (n:letter) := if n =? k-1 then [k-1; 0] else [S n].

(** After the substitution of letters, now the substitution of words *)

Definition ksubstw k : word -> word := apply (ksubst k).

(** Iterated substitution of word *)

Definition kword k n := napply (ksubst k) n [k-1].

(** The corresponding infinite word (limit of the qword sequence) *)

Definition kseq k := subst2seq (ksubst k) (k-1).

(* Compute take 20 (kseq 3). *)
(* [2; 0; 1; 2; 2; 0; 2; 0; 1; 2; 0; 1; 2; 2; 0; 1; 2; 2; 0; 2] *)

Lemma ksubst_noerase k : NoErase (ksubst k).
Proof.
 red. intros c. unfold ksubst. now case Nat.eqb_spec.
Qed.

Lemma ksubst_prolong k : Prolong (ksubst k) (k-1).
Proof.
 red. exists [0]. split. easy.
 unfold ksubst. now rewrite Nat.eqb_refl.
Qed.

Lemma kseq_SubstSeq k : SubstSeq (ksubst k) (kseq k) (k-1).
Proof.
 apply substseq_exists. apply ksubst_noerase. apply ksubst_prolong.
Qed.

Lemma ksubstw_app k u v : ksubstw k (u++v) = ksubstw k u ++ ksubstw k v.
Proof.
 apply apply_app.
Qed.

Lemma kword_S k n : kword k (S n) = ksubstw k (kword k n).
Proof.
 apply napply_alt.
Qed.

Lemma kseq_k_0 k : kseq k 0 = k-1.
Proof.
 reflexivity.
Qed.

Lemma kseq_k_1 k : kseq k 1 = 0.
Proof.
 unfold kseq, subst2seq, ksubst. simpl. now rewrite Nat.eqb_refl.
Qed.

Lemma ksubst_km1 k : ksubst k (k-1) = [k-1;0].
Proof.
 unfold ksubst. now rewrite Nat.eqb_refl.
Qed.

Lemma ksubst_km2 k : 1<k -> ksubst k (k-2) = [k-1].
Proof.
 intros K. unfold ksubst. case Nat.eqb_spec; intros. lia. f_equal. lia.
Qed.

(** kword letters are always in 0..k-1 *)

Lemma ksubst_letters k w :
 Forall (fun a => a < k) w ->
 Forall (fun a => a < k) (ksubstw k w).
Proof.
 induction w; simpl; auto.
 intros H; inversion_clear H. apply Forall_app. split; auto.
 unfold ksubst.
 case Nat.eqb_spec; intro; repeat (constructor; try lia).
Qed.

Lemma napply_ksubst_letters k n w :
 Forall (fun a => a < k) w ->
 Forall (fun a => a < k) (napply (ksubst k) n w).
Proof.
 induction n.
 - simpl. trivial.
 - rewrite napply_alt. intros. now apply ksubst_letters, IHn.
Qed.

Lemma kword_letters k n : k<>0 -> Forall (fun a => a < k) (kword k n).
Proof.
 intros K. apply napply_ksubst_letters. repeat constructor. lia.
Qed.

Lemma kseq_letters k n : k<>0 -> kseq k n < k.
Proof.
 intros K.
 unfold kseq, subst2seq.
 set (l := napply _ _ _).
 assert (Forall (fun a => a < k) l).
 { apply napply_ksubst_letters. repeat constructor. lia. }
 clearbody l. revert n. induction H; simpl; destruct n; trivial; lia.
Qed.

(** Initial values *)

Lemma kword_0 k : kword k 0 = [k-1].
Proof.
 reflexivity.
Qed.

Lemma kword_1 k : kword k 1 = [k-1;0].
Proof.
 cbn. unfold ksubst. now rewrite Nat.eqb_refl.
Qed.

Lemma ksubst_low0 k n : n < k -> napply (ksubst k) n [0] = [n].
Proof.
 induction n. auto.
 intros LE.
 rewrite napply_alt. rewrite IHn; try lia. simpl.
 unfold ksubst. case Nat.eqb_spec. lia. intros _. apply app_nil_r.
Qed.

Lemma kword_low k n : n <= k -> kword k n = k-1 :: List.seq 0 n.
Proof.
 induction n.
 - now rewrite kword_0.
 - intros LE.
   rewrite seq_S.
   cbn. unfold ksubst at 2. rewrite Nat.eqb_refl. simpl.
   rewrite napply_cons.
   rewrite ksubst_low0; auto; try lia.
   change (kword k n ++ [n] = k-1  :: List.seq 0 n ++ [n]).
   rewrite IHn; try lia. auto.
Qed.

(** Alt equation : *)

Lemma kword_eqn k n : 1<=k<=n -> kword k n = kword k (n-1) ++ kword k (n-k).
Proof.
 destruct n; try lia.
 intros (K,LE).
 remember (S n) as m eqn:E. rewrite E at 1.
 cbn. rewrite app_nil_r.
 unfold ksubst at 2. rewrite Nat.eqb_refl.
 rewrite napply_cons. fold (kword k n). replace (m-1) with n by lia.
 f_equal.
 replace n with (n-(k-1)+(k-1)) by lia.
 rewrite napply_add. rewrite ksubst_low0 by lia. fold (kword k (n-(k-1))).
 f_equal. lia.
Qed.

Lemma kword_01 k n : k<=1 -> kword k n = repeat 0 (2^n).
Proof.
 intros K.
 induction n.
 - simpl. unfold kword. simpl. f_equal; lia.
 - simpl. unfold kword. simpl. unfold ksubst at 2. rewrite Nat.eqb_refl.
   rewrite app_nil_r. rewrite napply_cons. replace 0 with (k-1) at 2 by lia.
   fold (kword k n). rewrite IHn. now rewrite repeat_app, Nat.add_0_r.
Qed.

Lemma kword_len k n : length (kword k n) = A k n.
Proof.
 destruct (Nat.eq_dec k 0) as [->|K].
 { rewrite kword_01 by lia. now rewrite repeat_length, A_0, A_1_pow2. }
 induction n as [[|n] IH] using lt_wf_ind.
 - now rewrite kword_0.
 - case (Nat.le_gt_cases k n) as [LE|GT].
   + rewrite kword_eqn by lia. rewrite app_length, !IH by lia.
     rewrite A_S. do 2 f_equal; lia.
   + rewrite kword_low by auto. simpl.
     rewrite seq_length. rewrite !A_base; lia.
Qed.

Lemma kword_nz k n : kword k n <> [].
Proof.
 unfold word. rewrite <- length_zero_iff_nil, kword_len.
 generalize (A_nz k n); lia.
Qed.

Lemma kseq_alt k n m a : n < A k m -> kseq k n = nth n (kword k m) a.
Proof.
 intros LE.
 rewrite (kseq_SubstSeq k m).
 change (napply _ _ _) with (kword k m).
 rewrite kword_len, take_nth; auto.
Qed.

Lemma kseq_01 k n : k <= 1 -> kseq k n = 0.
Proof.
 intros K.
 destruct n. rewrite kseq_k_0. lia.
 rewrite (kseq_alt k _ (S (invA k n)) 0) by apply invA_spec.
 rewrite kword_01 by trivial. apply nth_repeat.
Qed.

(** The kword are indeed prefixes of kseq *)

Lemma kseq_take_A k n : take (A k n) (kseq k) = kword k n.
Proof.
 apply take_carac.
 - apply kword_len.
 - intros. symmetry. now apply kseq_alt.
Qed.

(** Link between [kseq] and Zeckendorf decomposition :
    0 iff rank 0,
    1 iff rank 1,
    ...
    k-1 iff rank >= k-1 (or no rank, ie n=0)

    Hence 0 in [kseq] whenever the [f k] function is flat.
*)

Definition omin (oa:option nat) (b:nat) :=
  match oa with
  | None => b
  | Some a => Nat.min a b
  end.

Definition bounded_rank k n := omin (rank k n) (k-1).

Lemma kseq_bounded_rank k n : kseq k n = bounded_rank k n.
Proof.
 destruct (Nat.eq_dec k 0) as [->|K].
 { rewrite kseq_01 by lia. unfold bounded_rank, omin. simpl.
   destruct rank; lia. }
 induction n as [n IH] using lt_wf_ind.
 assert (E := decomp_sum k n).
 assert (D := decomp_delta k n).
 set (l := decomp k n) in *.
 destruct (rev l) as [|a rl] eqn:E'; apply rev_switch in E'.
 - rewrite E' in *. simpl in E. rewrite <- E. easy.
 - assert (A k a <= n < A k (S a)).
   { rewrite <- E, E', sumA_rev.
     split.
     + simpl; lia.
     + apply decomp_max; trivial. apply Delta_rev. now rewrite <- E'. }
   rewrite (kseq_alt k n (S a) 0) by lia.
   destruct (Nat.lt_ge_cases (S a) k) as [LT|LE].
   + rewrite kword_low by lia.
     destruct n as [|n]; try easy.
     change (nth _ _ _) with (nth n (List.seq 0 (S a)) 0).
     rewrite !A_base in H; try lia.
     replace n with a by lia.
     rewrite seq_nth by lia. simpl.
     unfold bounded_rank, rank. rewrite decomp_low; simpl; lia.
   + rewrite kword_eqn by lia.
     rewrite pred_succ.
     rewrite app_nth2; rewrite kword_len; try lia.
     rewrite <- kseq_alt.
     2:{ simpl in H. replace (S a -k) with (a - (k-1)); lia. }
     rewrite IH by (generalize (@A_nz k a); lia).
     unfold bounded_rank, rank.
     fold l; rewrite E'; simpl rev.
     replace (decomp _ _) with (rev rl).
     2:{ symmetry; apply decomp_carac; try lia.
         - rewrite E' in D. simpl in D. now apply Delta_app_iff in D.
         - revert E. rewrite E'. simpl. rewrite sumA_app. simpl. lia. }
     destruct (rev rl); simpl; lia.
Qed.

(** Projecting kseq to 0 and 1 (i.e. all letters except 0 become 1,
    i.e. applying (min 1) to kseq) gives the sequence of (f k) increments. *)

Lemma min_1_kseq_is_delta_f k n :
  1<k -> Nat.min 1 (kseq k n) = f k (S n) - f k n.
Proof.
 intros K.
 rewrite kseq_bounded_rank.
 destruct (@flat_rank_0 k lia n) as (_,H).
 destruct (@step_rank_nz k lia n) as (_,H').
 unfold bounded_rank. destruct (rank k n) as [[|r]|]; unfold omin.
 - simpl. rewrite H; trivial. lia.
 - rewrite H'; try easy. lia.
 - rewrite H'; try easy. lia.
Qed.

(** More generally, projecting letters p..k-1 to 1 and letters 0..p-1 to 0
    gives the sequence of (fs k p) increments. *)

Lemma kseq_above_p_is_delta_fs k p n :
  1<k -> p<k ->
  (if p <=? kseq k n then 1 else 0) = fs k p (S n) - fs k p n.
Proof.
 intros K Hp.
 rewrite kseq_bounded_rank.
 destruct (@fs_flat_iff' k lia p n) as (_,H).
 destruct (@fs_nonflat_iff' k lia p n) as (_,H').
 unfold bounded_rank. destruct (rank k n) as [r|]; unfold omin.
 - destruct (Nat.lt_decidable r p) as [LT|NLT]; case Nat.leb_spec; lia.
 - simpl in *. case Nat.leb_spec; lia.
Qed.

(** Another description of [kseq k n] :
    sum for p=1..k of [fs k p (n+1) - fs k p n] *)

Definition cumul_diff_fs k n :=
 cumul (fun p => fs k (S p) (S n) - fs k (S p) n) (k-1).

Lemma kseq_is_cumul_diff_fs k n : kseq k n = cumul_diff_fs k n.
Proof.
 rewrite kseq_bounded_rank. unfold bounded_rank, omin.
 destruct (rank k n) as [r|] eqn:E; simpl.
 - rewrite <- (cumul_ltb (k-1) r). unfold cumul_diff_fs.
   apply cumul_ext.
   intros m Hm.
   case Nat.ltb_spec; intros L.
   + destruct (@fs_nonflat_iff' k lia (S m) n) as (_,->); try lia.
     rewrite E; simpl; lia.
   + destruct (@fs_flat_iff' k lia (S m) n) as (_,->); try lia.
     rewrite E; simpl; lia.
 - rewrite rank_none in E. subst. unfold cumul_diff_fs.
   erewrite cumul_ext, (cumul_cst 1); try lia.
   intros x _. rewrite fs_k_0, fs_k_1. lia.
Qed.

(** Hence the sum of the n first letters of [kseq q] is
    the sum for p=1..k of [fs k p n]. *)

Lemma cumul_kseq_is_cumul_fs k n :
  cumul (kseq k) n = cumul (fun p => fs k (S p) n) (k-1).
Proof.
 induction n; cbn -[fs].
 - erewrite cumul_ext; auto using cumul_0, fs_k_0.
 - rewrite IHn, kseq_is_cumul_diff_fs. unfold cumul_diff_fs.
   rewrite <- cumul_add. apply cumul_ext.
   intros m Hm. generalize (fs_mono_S k (S m) n). lia.
Qed.

(** Counting letter 0 in [kseq q] leads back to the [f k] fonction. *)

Lemma f_count_0 k n : 1<k -> count (kseq k) 0 n + f k n = n.
Proof.
 intros K.
 induction n.
 - easy.
 - simpl.
   rewrite kseq_bounded_rank.
   unfold bounded_rank.
   destruct (f_step k n) as [E|E].
   + rewrite E. rewrite flat_rank_0 in E by lia. rewrite E. simpl. lia.
   + rewrite E. rewrite step_rank_nz in E by lia.
     destruct (rank k n) as [[|r]|]; simpl; try easy;
     replace (k-1) with (S (k-2)); simpl; lia.
Qed.

(** Similarly, counting all letters above [p] leads to [fs k p],
    the p-iterate of [f q]. *)

Lemma fs_count_above k p n :
  p < k -> fs k p n = count_above (kseq k) p n.
Proof.
 intros Hp.
 induction n.
 - simpl. apply fs_k_0.
 - simpl. rewrite kseq_bounded_rank.
   unfold bounded_rank.
   destruct (fs_step k p n) as [E|E].
   + rewrite E. rewrite fs_flat_iff' in E by lia.
     destruct (rank k n); simpl; try easy.
     red in E. case Nat.leb_spec; lia.
   + rewrite E. rewrite fs_nonflat_iff' in E by lia.
     destruct (rank k n); simpl in *; case Nat.leb_spec; lia.
Qed.

(** Particular case : p=k-1 *)

Lemma count_above_kseq_km1 k n :
  count_above (kseq k) (k-1) n = count (kseq k) (k-1) n.
Proof.
 induction n; simpl; auto.
 rewrite kseq_bounded_rank. unfold bounded_rank.
 destruct (rank k n); simpl in *; case Nat.leb_spec; case Nat.eqb_spec; lia.
Qed.

Lemma fs_count_km1 k n : fs k (k-1) n = count (kseq k) (k-1) n.
Proof.
 destruct (Nat.eq_dec k 0) as [->|K].
 - simpl. symmetry. apply count_all. intros m _. apply kseq_01; lia.
 - rewrite fs_count_above by lia. apply count_above_kseq_km1.
Qed.

(** Prefixes of kseq *)

Notation kprefix k n := (take n (kseq k)).

Lemma kprefix_length k n : length (kprefix k n) = n.
Proof.
 apply take_length.
Qed.

Lemma kprefix_carac k u :
  PrefixSeq u (kseq k) <-> u = kprefix k (length u).
Proof.
 reflexivity.
Qed.

Lemma kprefix_ok k n : PrefixSeq (kprefix k n) (kseq k).
Proof.
 red. now rewrite kprefix_length.
Qed.

Lemma kprefix_alt k n : kprefix k n = firstn n (kword k (invA_up k n)).
Proof.
 rewrite <- kseq_take_A. symmetry. apply firstn_take. apply invA_up_spec.
Qed.

Lemma kprefix_letters k n : k<>0 -> Forall (fun a => a < k) (kprefix k n).
Proof.
 intros K.
 induction n.
 - constructor.
 - rewrite take_S. apply Forall_app. split; trivial.
   repeat constructor. now apply kseq_letters.
Qed.

Lemma kprefix_A_kword k p : kprefix k (A k p) = kword k p.
Proof.
 apply kseq_take_A.
Qed.

Lemma kprefix_prefix_kword k n p :
  n <= A k p -> Prefix (kprefix k n) (kword k p).
Proof.
 intros H. rewrite <- kprefix_A_kword. now apply Prefix_take.
Qed.

Lemma kprefix_firstn_kword k n p :
  n <= A k p -> kprefix k n = firstn n (kword k p).
Proof.
 intros H. rewrite <- (take_length n (kseq k)) at 2.
 apply Prefix_equiv. now apply kprefix_prefix_kword.
Qed.

Lemma kword_prefix k p p' : p <= p' -> Prefix (kword k p) (kword k p').
Proof.
 apply napply_prefix_mono, ksubst_prolong.
Qed.

(** Full decomposition of any prefix of kword, then kseq (used in Lim) *)

Definition kwords k (l:list nat) : word := flat_map (kword k) l.

Lemma kwords_singl k n : kwords k [n] = kword k n.
Proof.
 unfold kwords. simpl. now apply app_nil_r.
Qed.

Lemma kwords_app k l l' : kwords k (l++l') = kwords k l ++ kwords k l'.
Proof.
 apply flat_map_app.
Qed.

Lemma kwords_cons k a l : kwords k (a::l) = kword k a ++ kwords k l.
Proof.
 change (a::l) with ([a]++l). now rewrite kwords_app, kwords_singl.
Qed.

Lemma ksubst_kwords k l :
 ksubstw k (kwords k l) = kwords k (map S l).
Proof.
 induction l; simpl; auto. now rewrite ksubstw_app, IHl, kword_S.
Qed.

Lemma decomp_prefix_kword k w n l : k<>0 ->
  Prefix w (kword k n) -> l = rev (decomp k (length w)) -> w = kwords k l.
Proof.
 intros K. revert w l. induction n as [n IH] using lt_wf_ind.
 intros w l P.
 destruct (Nat.le_gt_cases n k).
 - clear IH. rewrite kword_low in * by trivial.
   destruct (Prefix_cons_inv _ _ _ P) as [->|(w' & E' & P')].
   + simpl. now intros ->.
   + assert (LE := Prefix_len _ _ P'). rewrite seq_length in LE.
     apply Prefix_seq in P'.
     rewrite E'. simpl length. set (p := length w') in *.
     rewrite decomp_low by lia.
     fixpred. intros ->. simpl.
     rewrite app_nil_r, kword_low, <-P' by lia. trivial.
 - assert (P' := P). destruct P' as ([|a u] & E).
   + rewrite app_nil_r in E. rewrite E. rewrite kword_len.
     replace (decomp k (A k n)) with [n].
     2:{ symmetry; apply decomp_carac; try constructor; simpl; auto. }
     intros ->. simpl. now rewrite app_nil_r.
   + assert (LT : length w < A k n).
     { rewrite <- kword_len, <- E, app_length. simpl. lia. }
     clear  E.
     destruct n; [lia|].
     rewrite kword_eqn in P by lia.
     apply Prefix_app in P. destruct P as [P|(w' & -> & P)].
     * apply (IH n); try lia; auto. now fixpred.
     * rewrite app_length, kword_len in *. fixpred.
       rewrite Nat.add_comm, decomp_plus_A by (simpl in LT; lia).
       rewrite rev_app_distr. intros ->. rewrite kwords_app.
       simpl. f_equal. now rewrite app_nil_r.
       apply (IH (n-(k-1))); auto. lia.
       now replace (n-_) with (S n-k) by lia.
Qed.

Lemma decomp_prefix_kseq k n :
 k<>0 -> take n (kseq k) = kwords k (rev (decomp k n)).
Proof.
 intros K.
 assert (H := invA_spec k n). set (m := invA k n) in *.
 assert (H' : n <= A k (S m)) by lia. clear H. clearbody m.
 apply (decomp_prefix_kword _ _ (S m) _ K).
 - apply Prefix_nth_nat. intros p a. rewrite take_length. intros LT.
   rewrite take_nth by trivial.
   apply kseq_alt; lia.
 - now rewrite take_length.
Qed.

Lemma renorm_kwords k l :
 k<>0 -> Delta (k-1) l -> kwords k (rev (renorm k l)) = kwords k (rev l).
Proof.
 intros K.
 unfold renorm.
 generalize (Nat.le_refl (length l)). generalize (length l) at 2 3.
 intro n. revert l.
 induction n as [[|n] IH] using lt_wf_ind; intros l Hl D.
 - now destruct l.
 - destruct l as [|i l]; simpl in *; trivial.
   apply Delta_inv in D.
   destruct (renorm_loop k l n) as [|a l'] eqn:E.
   + simpl. rewrite kwords_app.
     rewrite <- (IH n); trivial; try lia. now rewrite E.
   + case Nat.eqb_spec; intros.
     * rewrite IH; try lia.
       2:{ change (length (S a :: l')) with (length (a::l')).
           rewrite <- E. rewrite renorm_loop_length; lia. }
       2:{ apply Delta_S_cons. fixpred. rewrite <- E.
           apply renorm_loop_delta; trivial. lia. }
       subst a. simpl. rewrite !kwords_app, !kwords_singl.
       rewrite kword_eqn by lia.
       replace (S _ - k) with i by lia. rewrite app_assoc. f_equal.
       fixpred. rewrite <- (kwords_singl k (i+(k-1))), <- kwords_app.
       change (_++_) with (rev (i+(k-1)::l')). rewrite <- E.
       apply IH; trivial; try lia.
     * rewrite <- E. simpl. rewrite !kwords_app. f_equal.
       apply IH; trivial; lia.
Qed.

Lemma prefix_kseq_laxdecomp k n l :
 k<>0 -> DeltaRev (k-1) l -> sumA k l = n -> take n (kseq k) = kwords k l.
Proof.
 rewrite <- Delta_rev. rewrite <- (rev_involutive l) at 2 3.
 rewrite sumA_rev. intros K D E.
 rewrite <- renorm_kwords by trivial.
 rewrite decomp_prefix_kseq; trivial. f_equal. f_equal.
 apply decomp_carac; trivial. now apply renorm_delta. now rewrite renorm_sum.
Qed.

Lemma count_kseq_decomp k n a : k<>0 ->
 count (kseq k) a n =
  list_sum (map (fun m => nbocc a (kword k m)) (decomp k n)).
Proof.
 intros K.
 rewrite count_nbocc, decomp_prefix_kseq by trivial. unfold kwords.
 rewrite flat_map_concat_map, nbocc_concat.
 now rewrite map_map, map_rev, list_sum_rev.
Qed.

(** Occurrences of letters when applying ksubst *)

Lemma nbocc_ksubst k : 1<k ->
 forall w,
 nbocc 0 (ksubstw k w) = nbocc (k-1) w /\
 nbocc (k-1) (ksubstw k w) = nbocc (k-2) w + nbocc (k-1) w /\
 forall p, p<k-2 -> nbocc (S p) (ksubstw k w) = nbocc p w.
Proof.
 intros K.
 induction w; simpl.
 - repeat split; lia.
 - simpl. rewrite !nbocc_app.
   destruct IHw as (IHw0 & IHwq & IHw).
   rewrite IHw0, IHwq. repeat split.
   + unfold ksubst. case Nat.eqb_spec; simpl; try lia.
     case Nat.eqb_spec; simpl; try lia.
   + unfold ksubst. case Nat.eqb_spec; try lia.
     * intros ->. cbn -[Nat.eqb]. rewrite Nat.eqb_refl.
       do 2 (case Nat.eqb_spec; try lia).
     * intros N. case Nat.eqb_spec; try lia.
       { intros ->. replace (S (k-2)) with (k-1) by lia. simpl.
         rewrite Nat.eqb_refl. lia. }
       { intros N'. cbn -[Nat.eqb]. case Nat.eqb_spec; try lia. }
   + intros p Hp. rewrite nbocc_app. rewrite (IHw p Hp).
     unfold ksubst. case Nat.eqb_spec; try lia.
     * intros ->. cbn -[Nat.eqb].
       do 3 (case Nat.eqb_spec; try lia).
     * intros N. simpl. lia.
Qed.

(* In [napply] of [ksubst], the initial letter doesn't matter much :
   low letters become [k-1] after some rounds of [ksubst], while
   unexpected letters stay large. *)

Lemma napply_ksubst_shift k p n : k<>0 -> p+n < k \/ k <= p ->
 napply (ksubst k) n [p] = [p+n].
Proof.
 intros K. revert p.
 induction n; simpl; intros.
 - f_equal. lia.
 - rewrite app_nil_r. unfold ksubst at 2.
   case Nat.eqb_spec; try lia. intros. rewrite IHn. f_equal; lia. lia.
Qed.

Lemma napply_ksubst_is_kword k p n : p < k -> k-1 <= n+p ->
 napply (ksubst k) n [p] = kword k (n+p-(k-1)).
Proof.
 intros. replace n with ((n+p-(k-1))+((k-1)-p)) at 1 by lia.
 rewrite napply_add, napply_ksubst_shift by lia.
 unfold kword; f_equal. f_equal. lia.
Qed.

(** We hence have an easy bound on lengths of n-iterates of ksubst on
   single letters. *)

Definition NapplySizeBound s n N :=
  forall a:letter, length (napply s n [a]) <= N.

Lemma Bound_A k n : k<>0 -> NapplySizeBound (ksubst k) n (A k n).
Proof.
 unfold NapplySizeBound. intros K a.
 destruct (Nat.le_gt_cases a (k-1)).
 - destruct (Nat.le_gt_cases (k-1) (n+a)).
   + rewrite napply_ksubst_is_kword by lia. rewrite kword_len.
     apply A_mono. lia.
   + rewrite napply_ksubst_shift by lia. simpl. apply A_nz.
 - rewrite napply_ksubst_shift by lia. simpl. apply A_nz.
Qed.

(** Counting occurrences of [k-1] and [0] in [kword] *)

Lemma nbocc_km1_kword k n : k<>0 -> nbocc (k-1) (kword k n) = A k (n-(k-1)).
Proof.
 intros K.
 induction n as [n IH] using lt_wf_ind.
 destruct (Nat.le_gt_cases n (k-1)).
 - rewrite kword_low by lia. simpl.
   rewrite Nat.eqb_refl, nbocc_notin.
   2:{ rewrite in_seq; lia. }
   now replace (n-(k-1)) with 0 by lia.
 - destruct n; try lia.
   rewrite kword_eqn, nbocc_app by lia.
   rewrite IH by lia.
   rewrite IH by lia.
   fixpred. replace (S n - (k-1)) with (S (n-(k-1))) by lia. rewrite A_S.
   do 2 f_equal. lia.
Qed.

Lemma nbocc_0_kword k n : 1<k -> nbocc 0 (kword k (S n)) = A k (n-(k-1)).
Proof.
 intros K.
 induction n as [n IH] using lt_wf_ind.
 destruct (Nat.le_gt_cases (S n) (k-1)).
 - rewrite kword_low by lia. simpl.
   rewrite nbocc_notin by (rewrite in_seq; lia).
   case Nat.eqb_spec; try lia.
   now replace (n-(k-1)) with 0 by lia.
 - destruct n; try lia.
   rewrite kword_eqn, nbocc_app by lia. fixpred.
   rewrite IH by lia.
   destruct (Nat.le_gt_cases (S n) (k-1)).
   + replace (S n - (k-1)) with 0 by lia. replace (n-(k-1)) with 0 by lia.
     replace (S (S n) - k) with 0 by lia.
     simpl. case Nat.eqb_spec; try lia.
   + replace (S (S n) - k) with (S (S n -k)) by lia.
     replace (S n - (k-1)) with (S (n - (k-1))) by lia.
     rewrite IH by lia. rewrite A_S. f_equal. f_equal. lia.
Qed.


(* Special case k=3

 0 -> 1
 1 -> 2
 2 -> 20

 Occurrence matrix :

 001
 100
 011

*)

Lemma nbocc_ksubst3 w :
 nbocc 0 (ksubstw 3 w) = nbocc 2 w /\
 nbocc 1 (ksubstw 3 w) = nbocc 0 w /\
 nbocc 2 (ksubstw 3 w) = nbocc 1 w + nbocc 2 w.
Proof.
 assert (H:1<3) by lia.
 destruct (nbocc_ksubst 3 H w) as (H0 & H1 & Hp). repeat split; trivial.
 apply Hp; lia.
Qed.

Definition tripleocc w := (nbocc 0 w, nbocc 1 w, nbocc 2 w).

Definition occurmatrix '(x,y,z) : nat*nat*nat := (z,x,y+z).

Lemma nbocc_ksubst3_bis w :
 tripleocc (ksubstw 3 w) = occurmatrix (tripleocc w).
Proof.
 unfold tripleocc.
 now destruct (nbocc_ksubst3 w) as (-> & -> & ->).
Qed.

Lemma len_nbocc_012 w :
  Forall (fun a => a < 3) w ->
  length w = nbocc 0 w + nbocc 1 w + nbocc 2 w.
Proof.
 intros. rewrite nbocc_total_lt with (k:=3); simpl; auto. lia.
Qed.

Lemma len_ksubst k w :
 length (ksubstw k w) = length w + nbocc (k-1) w.
Proof.
 induction w; simpl; auto.
 rewrite app_length, IHw.
 unfold ksubst at 1.
 case Nat.eqb_spec; simpl; lia.
Qed.

(* Special case k=4

 0 -> 1
 1 -> 2
 2 -> 3
 3 -> 30

 Occurrence matrix :

 0001
 1000
 0100
 0011

*)

Lemma nbocc_ksubst4 w :
 nbocc 0 (ksubstw 4 w) = nbocc 3 w /\
 nbocc 1 (ksubstw 4 w) = nbocc 0 w /\
 nbocc 2 (ksubstw 4 w) = nbocc 1 w /\
 nbocc 3 (ksubstw 4 w) = nbocc 2 w + nbocc 3 w.
Proof.
 assert (H:1<4) by lia.
 destruct (nbocc_ksubst 4 H w) as (H0 & H1 & Hp). repeat split; trivial.
 apply Hp; lia.
 apply Hp; lia.
Qed.

Definition fourocc w := (nbocc 0 w, nbocc 1 w, nbocc 2 w, nbocc 3 w).

Definition occurmatrix4 '(x,y,z,t) : nat*nat*nat*nat := (t,x,y,z+t).

Lemma nbocc_ksubst4_bis w :
 fourocc (ksubstw 4 w) = occurmatrix4 (fourocc w).
Proof.
 unfold fourocc.
 now destruct (nbocc_ksubst4 w) as (-> & -> & -> & ->).
Qed.

Lemma len_nbocc_0123 w :
  Forall (fun a => a < 4) w ->
  length w = nbocc 0 w + nbocc 1 w + nbocc 2 w + nbocc 3 w.
Proof.
 intros. rewrite nbocc_total_lt with (k:=4); simpl; auto. lia.
Qed.

(* From a Prefix of napply of a word to a prefix of napply of a letter *)

Lemma napply_prefix s n u v :
  NoErase s -> v<>[] ->
  Prefix u (napply s n v) ->
  exists w t a,
    Prefix (w++[a]) v /\ u = napply s n w ++ t /\ Prefix t (napply s n [a]).
Proof.
 intros NE. revert u.
 induction v; try easy.
 - intros u _. rewrite napply_cons. intros Pr.
   apply Prefix_app in Pr. destruct Pr as [Pr|(u' & E & Pr)].
   + exists [], u, a. rewrite napply_nil. simpl. split; auto. now exists v.
   + destruct (list_eq_dec Nat.eq_dec v []) as [->|NE'].
     * rewrite napply_nil in Pr. apply Prefix_nil in Pr. subst u'.
       rewrite app_nil_r in E.
       exists [], u, a. rewrite napply_nil.
       repeat split; subst; auto using Prefix_id.
     * destruct (IHv u' NE' Pr) as (w & t & b & Hv & E' & Ht).
       exists (a::w), t, b. repeat split; auto.
       { simpl. now apply Prefix_cons. }
       { now rewrite napply_cons, <- app_assoc, <- E', <- E. }
Qed.

(** Saari's Lemma 4 : decomposition of a prefix of s^n(a),
    leaving alone a final part whose size is below a certain threshold *)

Lemma Saari_lemma4 s a n w G M1 MG : G<>0 -> n<>0 ->
 NapplySizeBound s 1 M1 -> NapplySizeBound s G MG ->
 NoErase s ->
 Prefix w (napply s n [a]) ->
 exists l : list (nat * word), exists z,
  w = flat_map (fun '(ni,ui) => napply s ni ui) l ++ z
  /\ Forall (fun '(ni,ui) => length ui <= M1 /\ G <= ni < n) l
  /\ DeltaRev 1 (map fst l)
  /\ length z <= MG.
Proof.
 intros HG. revert a w.
 induction n as [n IH] using lt_wf_ind.
 intros a w Hn B1 BG NE Pr.
 destruct (Nat.le_gt_cases n G).
 - exists []. exists w. simpl. repeat split; auto. constructor.
   apply Prefix_len in Pr.
   etransitivity; [apply Pr|]. red in BG.
   rewrite <- (BG a). now apply napply_mono.
 - destruct n as [|n]; try easy.
   simpl in Pr. rewrite app_nil_r in Pr.
   destruct (napply_prefix s n w (s a) NE (NE a) Pr)
     as (w1 & w2 & b & H1 & H2 & H3).
   destruct (IH n (Nat.lt_succ_diag_r n) b w2)
     as (l & z & EQ & F & D & LE); auto; try lia.
   exists ((n,w1)::l), z; repeat split; auto.
   + simpl. now rewrite <- app_assoc, <-EQ.
   + constructor; try split; auto; try lia.
     * rewrite <- (B1 a). simpl. rewrite app_nil_r.
       apply Prefix_len in H1. rewrite app_length in H1. simpl in H1. lia.
     * clear -F. rewrite Forall_forall in *.
       intros (m,u) IN. apply F in IN. lia.
   + simpl. apply DeltaRev_alt. split; auto.
     intros y. rewrite in_map_iff. intros ((m,y') & <- & IN). simpl.
     rewrite Forall_forall in F. apply F in IN. lia.
Qed.

(* Same idea in a simpler version (decompose in letters instead of words).
   Should be enough for ksubst *)

Definition Reachable s a b := exists n, In b (napply s n [a]).

Lemma Reachable_trans s a b c :
  Reachable s a b -> Reachable s b c -> Reachable s a c.
Proof.
 intros (n,Hb) (m,Hc). exists (m+n). rewrite napply_add.
 destruct (in_split _ _ Hb) as (u & v & ->).
 rewrite napply_app, napply_cons, !in_app_iff. intuition.
Qed.

Lemma Saari_lemma4_bis s a n w G MG : G<>0 -> n<>0 ->
 NapplySizeBound s G MG ->
 NoErase s ->
 Prefix w (napply s n [a]) ->
 exists l : list (nat * letter), exists z,
  w = flat_map (fun '(ni,ui) => napply s ni [ui]) l ++ z
  /\ Forall (fun '(ni,ui) => G <= ni /\ Reachable s a ui) l
  /\ length z <= MG.
Proof.
 intros HG. revert a w.
 induction n as [n IH] using lt_wf_ind.
 intros a w Hn BG NE Pr.
 destruct (Nat.le_gt_cases n G).
 - exists []. exists w. simpl. repeat split; auto.
   apply Prefix_len in Pr.
   etransitivity; [apply Pr|]. red in BG.
   rewrite <- (BG a). now apply napply_mono.
 - destruct n as [|n]; try easy.
   simpl in Pr. rewrite app_nil_r in Pr.
   destruct (napply_prefix s n w (s a) NE (NE a) Pr)
     as (w1 & w2 & b & H1 & H2 & H3).
   destruct (IH n (Nat.lt_succ_diag_r n) b w2)
     as (l & z & EQ & F & LE); auto; try lia. clear IH.
   exists (map (fun u => (n,u)) w1 ++ l), z; repeat split; auto.
   + simpl. rewrite H2, EQ. rewrite app_assoc. f_equal.
     rewrite flat_map_app. f_equal.
     now rewrite flatmap_map, napply_flat_map.
   + apply Forall_app; split.
     * rewrite Forall_forall. intros (p,c).
       rewrite in_map_iff. intros (x & [= <- <-] & IN). split. lia.
       exists 1. simpl. rewrite app_nil_r. destruct H1 as (w3 & <-).
       rewrite !in_app_iff; intuition.
     * rewrite Forall_forall in *. intros (p,c) IN.
       destruct (F (p,c) IN). split; trivial. eapply Reachable_trans; eauto.
       exists 1. simpl. rewrite app_nil_r. destruct H1 as (w3 & <-).
       rewrite !in_app_iff; intuith.
Qed.

Lemma Reachable_ksubst k p :
  p < k -> forall p', Reachable (ksubst k) p p' <-> p' < k.
Proof.
 intros K p'. split.
 - intros (n,H).
   assert (F : Forall (fun a => a < k) [p]) by repeat (constructor; try lia).
   apply (napply_ksubst_letters _ n) in F.
   rewrite Forall_forall in F. now apply F.
 - intros K'.
   apply Reachable_trans with (k-1).
   + exists ((k-1)-p). rewrite napply_ksubst_shift by lia.
     replace (p+((k-1)-p)) with (k-1); simpl; lia.
   + apply Reachable_trans with 0.
     * exists 1. simpl. unfold ksubst. rewrite Nat.eqb_refl. simpl; intuition.
     * exists p'. rewrite napply_ksubst_shift by lia. simpl. lia.
Qed.

Lemma Saari_lemma4_ksubst k n w G : k<>0 -> G<>0 -> n<>0 ->
 Prefix w (kword k n) ->
 exists l : list nat, exists z,
  w = flat_map (kword k) l ++ z
  /\ Forall (Nat.le G) l
  /\ length z <= A k (k-1+G).
Proof.
 intros K HG Hn Pref.
 destruct (Saari_lemma4_bis (ksubst k) (k-1) n w (k-1+G) (A k (k-1+G))) as
  (l & z & E & F & LE); trivial; try lia.
 - apply Bound_A; auto.
 - apply ksubst_noerase.
 - exists (map (fun '(ni,ui) => ni+ui-(k-1)) l);
    exists z; repeat split; trivial.
   + rewrite E. f_equal. rewrite !flat_map_concat_map. f_equal.
     rewrite map_map. simpl. apply map_ext_in.
     intros (ni,ui) IN.
     rewrite Forall_forall in F. destruct (F _ IN) as (U,V).
     rewrite Reachable_ksubst in V; try lia.
     rewrite napply_ksubst_is_kword; trivial; try lia.
   + rewrite Forall_map.
     rewrite Forall_forall in *. intros (p,c) IN.
     destruct (F _ IN) as (U,V).
     rewrite Reachable_ksubst in V; try lia.
Qed.

Lemma count_kseq k n p :
  n <= A k p ->
  count (kseq k) 0 n = nbocc 0 (firstn n (kword k p)).
Proof.
 intros LE.
 rewrite count_nbocc. f_equal. now apply kprefix_firstn_kword.
Qed.

(** Is there a 0 at position n in [kseq k] ?
    If so, there's a [k-1] at the previous position. *)

Definition is_zero_at k n := (kseq k n =? 0).

Lemma rank_0_pred k n :
 k<>0 -> rank k n = Some 0 -> bounded_rank k (pred n) = k-1.
Proof.
 unfold rank. destruct (decomp k n) as [|r l] eqn:E; try easy.
 intros K [= ->].
 unfold bounded_rank, rank.
 assert (D := decomp_delta k n).
 rewrite E in D.
 rewrite (@decomp_carac k (pred n) l); trivial.
 2:{ now apply Delta_inv in D. }
 2:{ now rewrite <- (decomp_sum k n), E. }
 destruct l as [|r' l']; trivial. simpl.
 inversion_clear D. lia.
Qed.

Lemma k0_pred_km1 k n : kseq k n = 0 -> kseq k (pred n) = k-1.
Proof.
 destruct (Nat.le_gt_cases k 1) as [LE|K].
 { rewrite !kseq_01; lia. }
 rewrite !kseq_bounded_rank.
 unfold bounded_rank at 1, omin.
 destruct rank as [r|] eqn:E; try lia. intros Hr.
 replace r with 0 in * by lia. apply rank_0_pred; trivial; lia.
Qed.

(** Given two consecutive prefixes of [kseq], one of the two is
    a [ksubst] of a smaller prefix. *)

Lemma kseq_take_inv k n : 1<k ->
  kprefix k (n + if is_zero_at k n then 1 else 0) =
  ksubstw k (kprefix k (f k n)).
Proof.
 intros K.
 set (l := rev (decomp k n)).
 set (l' := map pred l).
 assert (D' : DeltaRev (k-1) l').
 { unfold l', l. rewrite map_rev, DeltaRev_rev.
   apply Delta_map with k. lia. apply decomp_delta. }
 assert (E : sumA k l' = f k n).
 { unfold l', l. rewrite map_rev, sumA_rev. symmetry. apply f_decomp; lia. }
 rewrite (prefix_kseq_laxdecomp k (f k n) l') by (trivial; lia).
 rewrite ksubst_kwords; auto.
 apply prefix_kseq_laxdecomp; try lia.
 - unfold l', l. rewrite map_map, map_rev, DeltaRev_rev.
   apply Delta_map with k. lia. apply decomp_delta.
 - unfold l', l. clear -K. rewrite map_map, map_rev, sumA_rev.
   destruct (decomp k n) as [|r l] eqn:E.
   + simpl. rewrite <- (decomp_sum k n), E. simpl.
     unfold is_zero_at; rewrite kseq_bounded_rank. unfold bounded_rank.
     replace (rank k 0) with (@None nat).
     2:{symmetry. now rewrite rank_none. }
     simpl. case Nat.eqb_spec; lia.
   + unfold is_zero_at. rewrite kseq_bounded_rank. unfold bounded_rank.
     unfold rank. rewrite E. simpl omin.
     case Nat.eqb_spec; intros.
     * replace r with 0 in * by lia. simpl.
       rewrite map_ext_in with (g:=id), map_id.
       2:{ intros a Ha. unfold id.
           assert (D := decomp_delta k n).
           rewrite E in D. apply Delta_nz' in D; try lia.
           assert (a<>0); try lia. now intros ->. }
       rewrite <- (decomp_sum k n), E. simpl. lia.
     * rewrite map_ext_in with (g:=id), map_id.
       now rewrite <- E, decomp_sum.
       assert (D := decomp_delta k n).
       rewrite E in D. apply Delta_nz in D; try lia.
       intros a Ha. unfold id. assert (a<>0); try lia. now intros ->.
Qed.

Lemma PrefixSeq_01 k u :
 k<=1 -> PrefixSeq u (kseq k) <-> u = repeat 0 (length u).
Proof.
 intros K.
 assert (E : forall n p, map (kseq k) (seq p n) = repeat 0 n).
 { induction n; simpl; intros; auto. rewrite kseq_01 by easy. f_equal; auto. }
 split.
 - unfold PrefixSeq, take. now rewrite E.
 - now rewrite <- (E (length u) 0).
Qed.

Lemma apply_ksubst_01 k n :
 k<=1 -> ksubstw k (repeat 0 n) = repeat 0 (2*n).
Proof.
 intros K.
 induction n; simpl; trivial.
 rewrite Nat.add_succ_r. unfold ksubst at 1.
 replace (k-1) with 0 by lia. simpl. now rewrite IHn.
Qed.

Lemma ksubst_prefix_inv k u :
  PrefixSeq u (kseq k) ->
  { v & { w |
      u = ksubstw k v ++ w /\ PrefixSeq v (kseq k) /\ (w=[]\/w=[k-1]) }}.
Proof.
 destruct (Nat.leb k 1) eqn:K1;
  apply Nat.leb_le in K1 || apply Nat.leb_gt in K1.
 { intros P.
   set (n := length u).
   exists (repeat 0 (n/2)), (repeat 0 (n mod 2)); repeat split.
   - apply PrefixSeq_01 in P; trivial. rewrite P.
     rewrite apply_ksubst_01, <- repeat_app; trivial.
     f_equal. apply Nat.div_mod_eq.
   - apply PrefixSeq_01; trivial. now rewrite repeat_length.
   - replace (k-1) with 0 by lia.
     assert (E : n mod 2 = 0 \/ n mod 2 = 1).
     { generalize (Nat.mod_upper_bound n 2); lia. }
     destruct E as [-> | ->]; simpl; [now left|now right]. }
 intros P.
 assert (E := kseq_take_inv k (length u) lia).
 remember (length u) as n eqn:U.
 unfold is_zero_at in *.
 destruct (Nat.eqb_spec (kseq k n) 0) as [N|N].
 - rewrite Nat.add_1_r, take_S in E.
   rewrite N in E.
   destruct n.
   + exfalso. now rewrite kseq_k_0 in N.
   + rewrite take_S, <- app_assoc in E.
     assert (f k (S n) <> 0).
     { intros H. rewrite H in E. simpl in E.
       apply (f_equal (@rev _)) in E. now rewrite rev_app_distr in E. }
     replace (f k (S n)) with (S (f k (S n) - 1)) in E by lia.
     rewrite take_S, ksubstw_app in E. simpl in E. rewrite app_nil_r in E.
     set (m := f k (S n) - 1) in *.
     exists (take m (kseq k)), [k-1]; repeat split.
     * apply (f_equal (@rev _)) in E. rewrite !rev_app_distr in E.
       simpl in E.
       unfold ksubst in E at 1.
       destruct (Nat.eqb_spec (kseq k m) (k-1)) as [M|M]; try easy.
       simpl in E. injection E as N' E. apply rev_inj in E.
       rewrite <- E, P, <- U, take_S. f_equal. now f_equal.
     * red. f_equal. now rewrite take_length.
     * now right.
 - rewrite Nat.add_0_r in E.
   exists (take (f k n) (kseq k)), []; repeat split.
   + rewrite <- E, app_nil_r. rewrite P. now f_equal.
   + red. f_equal. now rewrite take_length.
   + now left.
Qed.

(** The preimage by ksubst is unique if it exists *)

Lemma ksubstw_inv k :
  forall u v, ksubstw k u = ksubstw k v -> u = v.
Proof.
 intros u v H. apply rev_inj.
 rewrite <- (rev_involutive u), <- (rev_involutive v) in H. revert H.
 generalize (rev u) as ru, (rev v) as rv. clear u v.
 induction ru as [|a u]; destruct rv as [|b v]; simpl; auto.
 - rewrite ksubstw_app. simpl. rewrite app_nil_r.
   intros E. symmetry in E. apply length_zero_iff_nil in E.
   rewrite app_length in E. unfold ksubst in E.
   destruct (Nat.eqb b (k-1)); simpl in E; lia.
 - rewrite ksubstw_app. simpl. rewrite app_nil_r.
   intros E. apply length_zero_iff_nil in E.
   rewrite app_length in E. unfold ksubst in E.
   destruct (Nat.eqb a (k-1)); simpl in E; lia.
 - rewrite !ksubstw_app. simpl. rewrite !app_nil_r.
   unfold ksubst. simpl.
   do 2 case Nat.eqb_spec; intros; subst.
   + apply app_inv' in H; trivial. f_equal. apply IHu, H.
   + apply (f_equal (@rev nat)) in H. now rewrite !rev_app_distr in H.
   + apply (f_equal (@rev nat)) in H. now rewrite !rev_app_distr in H.
   + apply app_inv' in H; trivial.
     destruct H as (H,[= ->]). f_equal. apply IHu, H.
Qed.

(** More on PrefixSeq *)

Lemma PrefixSeq_app_r u v f : PrefixSeq (u++v) f -> PrefixSeq u f.
Proof.
 unfold PrefixSeq, take. rewrite app_length, seq_app, map_app. intros E.
 apply app_inv in E. apply E. now rewrite map_length, seq_length.
Qed.

Lemma Prefix_PrefixSeq u v f : Prefix u v -> PrefixSeq v f -> PrefixSeq u f.
Proof.
 intros (u' & <-). apply PrefixSeq_app_r.
Qed.

Lemma PrefixSeq_incl w u v :
  length u <= length v -> PrefixSeq u w -> PrefixSeq v w -> Prefix u v.
Proof.
 unfold PrefixSeq. intros H -> ->. now apply Prefix_take.
Qed.

Lemma PrefixSeq_unique w u v :
  length u = length v -> PrefixSeq u w -> PrefixSeq v w -> u = v.
Proof.
 intros. apply Prefix_antisym; eapply PrefixSeq_incl; eauto; lia.
Qed.

Lemma PrefixSeq_alt s a :
  NoErase s -> Prolong s a ->
  forall u,
    PrefixSeq u (subst2seq s a) <-> Prefix u (napply s (length u) [a]).
Proof.
 intros NE PR u. unfold PrefixSeq.
 split.
 - generalize (length u). intros n Hu.
   rewrite Prefix_nth_nat. intros m b Hm.
   subst u. rewrite take_length in Hm.
   rewrite take_nth by trivial.
   rewrite <- subst2seq_indep; trivial; lia.
 - set (n := length u). intros Hu.
   symmetry. apply take_carac; trivial.
   intros m b Hm. rewrite Prefix_nth_nat in Hu.
   rewrite Hu by trivial. symmetry. apply subst2seq_indep; trivial. lia.
Qed.

Lemma PrefixSeq_alt' s a :
  NoErase s -> Prolong s a ->
  forall u,
    PrefixSeq u (subst2seq s a) <-> exists m, Prefix u (napply s m [a]).
Proof.
 intros NE PR u. rewrite PrefixSeq_alt by trivial.
 split.
 - intros H. now exists (length u).
 - intros (m,H). destruct (Nat.le_gt_cases m (length u)) as [L|L].
   + eapply Prefix_trans; eauto. apply napply_prefix_mono; trivial.
   + eapply Prefix_Prefix; eauto.
     * apply Nat.lt_le_incl, noerase_prolong_napply_len; trivial.
     * apply napply_prefix_mono; trivial; lia.
Qed.

Lemma PrefixSeq_apply s a :
  NoErase s -> Prolong s a ->
  forall u,
   PrefixSeq u (subst2seq s a) ->
   PrefixSeq (apply s u) (subst2seq s a).
Proof.
  intros NE PR u.
  rewrite !PrefixSeq_alt' by trivial.
  intros (m,(u',E)). exists (S m).
  rewrite napply_alt, <- E, apply_app. now exists (apply s u').
Qed.

Lemma PrefixSeq_napply s a n :
  NoErase s -> Prolong s a ->
  forall u,
   PrefixSeq u (subst2seq s a) ->
   PrefixSeq (napply s n u) (subst2seq s a).
Proof.
  intros NE PR.
  induction n; trivial.
  intros u Hu. simpl. apply IHn, PrefixSeq_apply; trivial.
Qed.

Lemma ksubstw_prefix k u :
 PrefixSeq u (kseq k) -> PrefixSeq (ksubstw k u) (kseq k).
Proof.
  apply PrefixSeq_apply. apply ksubst_noerase. apply ksubst_prolong.
Qed.

(** A nonerasing substitution can be applied to an infinite word *)

Definition SubstSekseq (s : subst)(f g : sequence) :=
 forall u, PrefixSeq u f -> PrefixSeq (apply s u) g.

Definition applyseq (s : subst) (f : sequence) :=
  fun n => nth n (apply s (take (S n) f)) 0.

Lemma applyseq_ok s f : NoErase s -> SubstSekseq s f (applyseq s f).
Proof.
 intros Hs u Hu. unfold PrefixSeq in *.
 symmetry. apply take_carac; trivial.
 intros m a Hm. unfold applyseq.
 rewrite nth_indep with (d' := 0); trivial.
 destruct (Nat.le_gt_cases (length u) (S m)) as [LE|GT].
 - assert (PR: Prefix u (take (S m) f)).
   { rewrite Hu. now apply Prefix_take. }
   destruct PR as (v & <-).
   rewrite apply_app, app_nth1; trivial.
 - assert (PR: Prefix (take (S m) f) u).
   { rewrite Hu. apply Prefix_take; lia. }
   destruct PR as (v & E). rewrite <- E.
   rewrite apply_app, app_nth1; trivial.
   red. rewrite <- (take_length (S m) f) at 1.
   now apply apply_grow.
Qed.

Lemma subst_seq_exists (s : subst)(f : sequence) :
 NoErase s -> exists g, SubstSekseq s f g.
Proof.
 intros Hs. exists (applyseq s f). now apply applyseq_ok.
Qed.

Lemma subst_seq_unique s f g g' :
 NoErase s -> SubstSekseq s f g -> SubstSekseq s f g' ->
 forall n, g n = g' n.
Proof.
 intros Hs Hg Hg' n.
 set (u := take (S n) f).
 assert (Hu : PrefixSeq u f).
 { red. unfold u. now rewrite take_length. }
 assert (n < length (apply s u)).
 { apply Nat.lt_le_trans with (length u).
   - unfold u. rewrite take_length; lia.
   - now apply apply_grow. }
 specialize (Hg u Hu).
 specialize (Hg' u Hu). red in Hg, Hg'.
 rewrite <- (take_nth g (length (apply s u)) n 0); auto.
 rewrite <- (take_nth g' (length (apply s u)) n 0); auto.
 now rewrite <- Hg, <- Hg'.
Qed.

Lemma kseq_fixpoint k n : applyseq (ksubst k) (kseq k) n = kseq k n.
Proof.
 apply (subst_seq_unique (ksubst k) (kseq k)).
 - apply ksubst_noerase.
 - apply applyseq_ok, ksubst_noerase.
 - intro u. apply ksubstw_prefix.
Qed.

(** Letters in kseq, what's before, what's after *)

Definition next_letter k a := if a =? (k-1) then 0 else S a.
Definition prev_letter k a := if a =? 0 then k-1 else pred a.

Lemma next_letter_lt k a : a < k -> next_letter k a < k.
Proof.
 intros Ha. unfold next_letter. case Nat.eqb_spec; lia.
Qed.

Lemma next_letter_km1 k : next_letter k (k-1) = 0.
Proof.
 unfold next_letter. now rewrite Nat.eqb_refl.
Qed.

Lemma prev_letter_lt k a : a < k -> prev_letter k a < k.
Proof.
 intros Ha. unfold prev_letter. case Nat.eqb_spec; lia.
Qed.

Lemma next_letter_alt k a : a < k -> next_letter k a = (S a) mod k.
Proof.
 intros Ha. unfold next_letter.
 case Nat.eqb_spec.
 - intros ->. symmetry. fixpred. apply Nat.mod_same; lia.
 - intros. symmetry. apply Nat.mod_small. lia.
Qed.

Lemma prev_letter_alt k a : a < k -> prev_letter k a = (a+(k-1)) mod k.
Proof.
 intros Ha. unfold prev_letter.
 case Nat.eqb_spec.
 - intros ->. symmetry. apply Nat.mod_small. lia.
 - intros. replace (a+(k-1)) with (a-1 + 1*k) by lia.
   rewrite Nat.mod_add, Nat.mod_small; lia.
Qed.

Lemma next_prev_letter k a : a < k -> next_letter k (prev_letter k a) = a.
Proof.
 intros Ha. unfold prev_letter.
 case Nat.eqb_spec.
 - intros ->. apply next_letter_km1.
 - intros. unfold next_letter. case Nat.eqb_spec; lia.
Qed.

Lemma prev_next_letter k a : a < k -> prev_letter k (next_letter k a) = a.
Proof.
 intros Ha. unfold next_letter.
 case Nat.eqb_spec; trivial.
 intros ->. unfold prev_letter. now rewrite Nat.eqb_refl.
Qed.

Lemma ksubst_next_letter k a : a<>k-1 -> ksubst k a = [next_letter k a].
Proof.
 intros A. unfold ksubst, next_letter. case Nat.eqb_spec; auto; lia.
Qed.

Lemma kseq_prev_letter k p :
 kseq k p <> k-1 -> kseq k (p-1) = prev_letter k (kseq k p).
Proof.
 intros Ha.
 assert (K : 1<k).
 { apply Nat.lt_nge. contradict Ha. rewrite kseq_01; lia. }
 assert (Ha' := kseq_letters k p).
 remember (kseq k p) as a eqn:Ea in *.
 rewrite kseq_bounded_rank in *.
 unfold bounded_rank, omin, rank in *.
 set (l := decomp k p) in *.
 destruct l as [|r l'] eqn:Hl; try lia.
 replace r with a in * by lia.
 rewrite decomp_pred; try lia. fold l. rewrite Hl. simpl.
 destruct a as [|a]; unfold prev_letter; simpl.
 - assert (D := decomp_delta k p). fold l in D. rewrite Hl in D.
   destruct l'; simpl; trivial. inversion_clear D. lia.
 - replace (a-(k-1)) with 0 by lia. simpl. lia.
Qed.

Lemma kseq_next_letter k p :
  kseq k (S p) <> k-1 -> kseq k (S p) = next_letter k (kseq k p).
Proof.
 intros Ha.
 assert (K : 1<k).
 { apply Nat.lt_nge. contradict Ha. rewrite kseq_01; lia. }
 replace p with (S p-1) at 2 by lia.
 rewrite kseq_prev_letter; trivial. rewrite next_prev_letter; trivial.
 apply kseq_letters. lia.
Qed.

Lemma kseq_next_km2 k p : kseq k p = k-2 -> kseq k (S p) = k-1.
Proof.
 intros E.
 destruct (Nat.eq_dec (kseq k (S p)) (k-1)) as [E'|E']; trivial.
 rewrite kseq_next_letter, E; trivial.
 unfold next_letter.
 case Nat.eqb_spec; lia.
Qed.

Lemma all_letters_occur k a : a < k -> kseq k (S a) = a.
Proof.
 intros Ha. rewrite kseq_bounded_rank. unfold bounded_rank, rank.
 replace (decomp k (S a)) with [a]. simpl. lia.
 symmetry. apply decomp_carac. lia. constructor. simpl. rewrite A_base; lia.
Qed.

Lemma count_le_prev_letter k a n : a < k-1 ->
  count (kseq k) a n <= count (kseq k) (prev_letter k a) n.
Proof.
 intros Ha.
 induction n as [[|n] IH] using lt_wf_ind; simpl; trivial.
 assert (IHn := IH n lia).
 do 2 case Nat.eqb_spec; intros E2 E1; try lia. clear IHn.
 destruct n; simpl.
 - rewrite kseq_k_0 in *. unfold prev_letter in *.
   destruct (Nat.eqb_spec a 0) as [->|E3]; lia.
 - specialize (IH n lia).
   assert (E3 := kseq_prev_letter k (S n) lia).
   rewrite E1 in E3.
   replace (S n -1) with n in E3 by lia. do 2 case Nat.eqb_spec; lia.
Qed.

Lemma count_le_lower_letter k a b n : a <= b < k-1 ->
 count (kseq k) b n <= count (kseq k) a n.
Proof.
 intros (AB,BQ). induction AB; trivial.
 etransitivity; [ | apply IHAB; lia ].
 replace m with (prev_letter k (S m)) at 2 by easy.
 apply count_le_prev_letter; trivial.
Qed.

Lemma count_le_count_km1 k a n : count (kseq k) a n <= count (kseq k) (k-1) n.
Proof.
 destruct (Nat.eq_dec a (k-1)) as [->|Ha]; trivial.
 destruct (Nat.ltb_spec (k-1) a) as [Ha'|Ha'].
 - replace (count (kseq k) a n) with 0; try lia. symmetry. apply count_0.
   intros x _.
   destruct (Nat.eq_dec k 0) as [->|K].
   + rewrite kseq_01; lia.
   + generalize (kseq_letters k x). lia.
 - transitivity (count (kseq k) 0 n).
   + apply count_le_lower_letter; lia.
   + replace (k-1) with (prev_letter k 0) at 3 by easy.
     apply count_le_prev_letter; lia.
Qed.
